// Copyright (c) The Starcoin Core Contributors
// SPDX-License-Identifier: Apache-2.0

use std::fs::File;
use std::io::{BufRead, BufReader};
use std::path::PathBuf;
use std::sync::Arc;
use tokio::task;
use std::time::SystemTime;
use anyhow::bail;
use atomic_counter::AtomicCounter;
use indicatif::{ProgressBar, ProgressStyle};

use starcoin_chain::verifier::{
    BasicVerifier, ConsensusVerifier, FullVerifier, NoneVerifier, Verifier,
};

use starcoin_types::block::{Block, BlockHeader};

#[derive(Debug, Parser)]
#[clap(name = "verify_head", about = "verify head")]
pub struct VerifyHeadOptions {
    #[clap(long, short = 'i', parse(from_os_str))]
    /// input file, like accounts.csv
    pub input_path: PathBuf,
}

// pub fn verify_modules_via_export_file(input_path: PathBuf) -> anyhow::Result<()> {
//     let start_time = SystemTime::now();
//     let file_name = input_path.display().to_string();
//     let reader = BufReader::new(File::open(input_path)?);
//     let mut blocks = vec![];
//     for record in reader.lines() {
//         let record = record?;
//         let block: Block = serde_json::from_str(record.as_str())?;
//
//         blocks.push(block);
//     }
//
//     if blocks.is_empty() {
//         println!("file {} has apply", file_name);
//         return Ok(());
//     }
//
//     if let Some(last_block) = blocks.last() {
//         let start = blocks.get(0).unwrap().header().number();
//         let end = last_block.header().number();
//         println!("verify [{},{}] block number", start, end);
//     }
//     let use_time = SystemTime::now().duration_since(start_time)?;
//     println!("load blocks from file use time: {:?}", use_time.as_millis());
//     let start_time = SystemTime::now();
//     let bar = ProgressBar::new(blocks.len() as u64);
//     bar.set_style(
//         ProgressStyle::default_bar()
//             .template("[{elapsed_precise}] {bar:100.cyan/blue} {percent}% {msg}"),
//     );
//
//     let success_counter = Arc::new(atomic_counter::RelaxedCounter::new(0));
//     let error_counter = Arc::new(atomic_counter::RelaxedCounter::new(0));
//     for block in blocks {
//         let total_modules = success_counter.get() + error_counter.get();
//         let block_number = block.header().number();
//         let success_counter = success_counter.clone();
//         let error_counter = error_counter.clone();
//
//         task::spawn(async move {
//             let (success_count, errors) = verify_block_modules(block);
//             if !errors.is_empty() {
//                 println!(
//                     "verify block modules {} error modules: {:?}",
//                     block_number, errors
//                 );
//             }
//             success_counter.add(success_count);
//             error_counter.add(errors.len());
//         });
//         bar.set_message(format!(
//             "verify block {} , total_modules: {}",
//             block_number, total_modules
//         ));
//         bar.inc(1);
//     }
//     bar.finish();
//     let use_time = SystemTime::now().duration_since(start_time)?;
//     println!("verify block modules use time: {:?}, success modules: {}, error modules: {}, total modules: {}", use_time.as_secs(), success_counter.get(), error_counter.get(), success_counter.get() + error_counter.get());
//     if error_counter.get() > 0 {
//         bail!("verify head error");
//     }
//     Ok(())
// }
//
// fn verify(hex: BlockHeader) -> bool {
//     false
// }