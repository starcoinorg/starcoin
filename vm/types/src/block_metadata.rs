// Copyright (c) The Starcoin Core Contributors
// SPDX-License-Identifier: Apache-2.0

// Copyright (c) The Diem Core Contributors
// SPDX-License-Identifier: Apache-2.0

use crate::account_address::AccountAddress;
use crate::genesis_config::ChainId;
use crate::transaction::authenticator::AuthenticationKey;
use serde::{Deserialize, Serialize};
use starcoin_crypto::{
    hash::{CryptoHash, CryptoHasher},
    HashValue,
};

/// Struct that will be persisted on chain to store the information of the current block.
///
/// The flow will look like following:
/// 1. The executor will pass this struct to VM at the end of a block proposal.
/// 2. The VM will use this struct to create a special system transaction that will modify the on
///    chain resource that represents the information of the current block. This transaction can't
///    be emitted by regular users and is generated by each of the validators on the fly. Such
///    transaction will be executed before all of the user-submitted transactions in the blocks.
/// 3. Once that special resource is modified, the other user transactions can read the consensus
///    info by calling into the read method of that resource, which would thus give users the
///    information such as the current leader.
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize, CryptoHasher, CryptoHash)]
pub struct BlockMetadata {
    /// Parent block hash.
    parent_hash: HashValue,
    timestamp: u64,
    author: AccountAddress,
    author_auth_key: Option<AuthenticationKey>,
    uncles: u64,
    number: u64,
    chain_id: ChainId,
    parent_gas_used: u64,
}

impl BlockMetadata {
    pub fn new(
        parent_hash: HashValue,
        timestamp: u64,
        author: AccountAddress,
        author_auth_key: Option<AuthenticationKey>,
        uncles: u64,
        number: u64,
        chain_id: ChainId,
        parent_gas_used: u64,
    ) -> Self {
        Self {
            parent_hash,
            timestamp,
            author,
            author_auth_key,
            uncles,
            number,
            chain_id,
            parent_gas_used,
        }
    }

    pub fn into_inner(
        self,
    ) -> (
        HashValue,
        u64,
        AccountAddress,
        Option<AuthenticationKey>,
        u64,
        u64,
        ChainId,
        u64,
    ) {
        (
            self.parent_hash,
            self.timestamp,
            self.author,
            self.author_auth_key,
            self.uncles,
            self.number,
            self.chain_id,
            self.parent_gas_used,
        )
    }

    pub fn parent_hash(&self) -> HashValue {
        self.parent_hash
    }

    pub fn timestamp(&self) -> u64 {
        self.timestamp
    }

    pub fn number(&self) -> u64 {
        self.number
    }

    pub fn chain_id(&self) -> ChainId {
        self.chain_id
    }
}
