// Copyright Â© Starcoin Foundation
// SPDX-License-Identifier: Apache-2.0

// This file was generated. Do not modify!
//
// To update this code, run: `cargo run --release -p framework`.

// Conversion library between a structured representation of a Move script call (`ScriptCall`) and the
// standard BCS-compatible representation used in Starcoin transactions (`Script`).
//
// This code was generated by compiling known Script interfaces ("ABIs") with the tool `starcoin-sdk-builder`.

#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(clippy::too_many_arguments)]
#![allow(clippy::arc_with_non_send_sync)]
#![allow(clippy::get_first)]
#![allow(unused_imports)]
use move_core_types::{
    ident_str,
    language_storage::{ModuleId, TypeTag},
};
use starcoin_vm_types::{
    account_address::AccountAddress,
    transaction::{EntryFunction, TransactionPayload},
};
use std::collections::BTreeMap as Map;

type Bytes = Vec<u8>;

/// Structured representation of a call into a known Move entry function.
/// ```ignore
/// impl EntryFunctionCall {
///     pub fn encode(self) -> TransactionPayload { .. }
///     pub fn decode(&TransactionPayload) -> Option<EntryFunctionCall> { .. }
/// }
/// ```
#[derive(Clone, Debug, PartialEq, Eq)]
#[allow(clippy::large_enum_variant)]
#[cfg_attr(feature = "fuzzing", derive(proptest_derive::Arbitrary))]
#[cfg_attr(feature = "fuzzing", proptest(no_params))]
pub enum EntryFunctionCall {
    /// Offers rotation capability on behalf of `account` to the account at address `recipient_address`.
    /// An account can delegate its rotation capability to only one other address at one time. If the account
    /// has an existing rotation capability offer, calling this function will update the rotation capability offer with
    /// the new `recipient_address`.
    /// Here, `rotation_capability_sig_bytes` signature indicates that this key rotation is authorized by the account owner,
    /// and prevents the classic "time-of-check time-of-use" attack.
    /// For example, users usually rely on what the wallet displays to them as the transaction's outcome. Consider a contract that with 50% probability
    /// (based on the current timestamp in Move), rotates somebody's key. The wallet might be unlucky and get an outcome where nothing is rotated,
    /// incorrectly telling the user nothing bad will happen. But when the transaction actually gets executed, the attacker gets lucky and
    /// the execution path triggers the account key rotation.
    /// We prevent such attacks by asking for this extra signature authorizing the key rotation.
    ///
    /// @param rotation_capability_sig_bytes is the signature by the account owner's key on `RotationCapabilityOfferProofChallengeV2`.
    /// @param account_scheme is the scheme of the account (ed25519 or multi_ed25519).
    /// @param account_public_key_bytes is the public key of the account owner.
    /// @param recipient_address is the address of the recipient of the rotation capability - note that if there's an existing rotation capability
    /// offer, calling this function will replace the previous `recipient_address` upon successful verification.
    AccountOfferRotationCapability {
        rotation_capability_sig_bytes: Vec<u8>,
        account_scheme: u8,
        account_public_key_bytes: Vec<u8>,
        recipient_address: AccountAddress,
    },

    /// Offers signer capability on behalf of `account` to the account at address `recipient_address`.
    /// An account can delegate its signer capability to only one other address at one time.
    /// `signer_capability_key_bytes` is the `SignerCapabilityOfferProofChallengeV2` signed by the account owner's key
    /// `account_scheme` is the scheme of the account (ed25519 or multi_ed25519).
    /// `account_public_key_bytes` is the public key of the account owner.
    /// `recipient_address` is the address of the recipient of the signer capability - note that if there's an existing
    /// `recipient_address` in the account owner's `SignerCapabilityOffer`, this will replace the
    /// previous `recipient_address` upon successful verification (the previous recipient will no longer have access
    /// to the account owner's signer capability).
    AccountOfferSignerCapability {
        signer_capability_sig_bytes: Vec<u8>,
        account_scheme: u8,
        account_public_key_bytes: Vec<u8>,
        recipient_address: AccountAddress,
    },

    /// Revoke any rotation capability offer in the specified account.
    AccountRevokeAnyRotationCapability {},

    /// Revoke any signer capability offer in the specified account.
    AccountRevokeAnySignerCapability {},

    /// Revoke the rotation capability offer given to `to_be_revoked_recipient_address` from `account`
    AccountRevokeRotationCapability {
        to_be_revoked_address: AccountAddress,
    },

    /// Revoke the account owner's signer capability offer for `to_be_revoked_address` (i.e., the address that
    /// has a signer capability offer from `account` but will be revoked in this function).
    AccountRevokeSignerCapability {
        to_be_revoked_address: AccountAddress,
    },

    /// Generic authentication key rotation function that allows the user to rotate their authentication key from any scheme to any scheme.
    /// To authorize the rotation, we need two signatures:
    /// - the first signature `cap_rotate_key` refers to the signature by the account owner's current key on a valid `RotationProofChallenge`,
    /// demonstrating that the user intends to and has the capability to rotate the authentication key of this account;
    /// - the second signature `cap_update_table` refers to the signature by the new key (that the account owner wants to rotate to) on a
    /// valid `RotationProofChallenge`, demonstrating that the user owns the new private key, and has the authority to update the
    /// `OriginatingAddress` map with the new address mapping `<new_address, originating_address>`.
    /// To verify these two signatures, we need their corresponding public key and public key scheme: we use `from_scheme` and `from_public_key_bytes`
    /// to verify `cap_rotate_key`, and `to_scheme` and `to_public_key_bytes` to verify `cap_update_table`.
    /// A scheme of 0 refers to an Ed25519 key and a scheme of 1 refers to Multi-Ed25519 keys.
    /// `originating address` refers to an account's original/first address.
    ///
    /// Here is an example attack if we don't ask for the second signature `cap_update_table`:
    /// Alice has rotated her account `addr_a` to `new_addr_a`. As a result, the following entry is created, to help Alice when recovering her wallet:
    /// `OriginatingAddress[new_addr_a]` -> `addr_a`
    /// Alice has had a bad day: her laptop blew up and she needs to reset her account on a new one.
    /// (Fortunately, she still has her secret key `new_sk_a` associated with her new address `new_addr_a`, so she can do this.)
    ///
    /// But Bob likes to mess with Alice.
    /// Bob creates an account `addr_b` and maliciously rotates it to Alice's new address `new_addr_a`. Since we are no longer checking a PoK,
    /// Bob can easily do this.
    ///
    /// Now, the table will be updated to make Alice's new address point to Bob's address: `OriginatingAddress[new_addr_a]` -> `addr_b`.
    /// When Alice recovers her account, her wallet will display the attacker's address (Bob's) `addr_b` as her address.
    /// Now Alice will give `addr_b` to everyone to pay her, but the money will go to Bob.
    ///
    /// Because we ask for a valid `cap_update_table`, this kind of attack is not possible. Bob would not have the secret key of Alice's address
    /// to rotate his address to Alice's address in the first place.
    AccountRotateAuthenticationKey {
        from_scheme: u8,
        from_public_key_bytes: Vec<u8>,
        to_scheme: u8,
        to_public_key_bytes: Vec<u8>,
        cap_rotate_key: Vec<u8>,
        cap_update_table: Vec<u8>,
    },

    /// Private entry function for key rotation that allows the signer to update their authentication key.
    /// Note that this does not update the `OriginatingAddress` table because the `new_auth_key` is not "verified": it
    /// does not come with a proof-of-knowledge of the underlying SK. Nonetheless, we need this functionality due to
    /// the introduction of non-standard key algorithms, such as passkeys, which cannot produce proofs-of-knowledge in
    /// the format expected in `rotate_authentication_key`.
    AccountRotateAuthenticationKeyCall {
        new_auth_key: Vec<u8>,
    },

    AccountRotateAuthenticationKeyWithRotationCapability {
        rotation_cap_offerer_address: AccountAddress,
        new_scheme: u8,
        new_public_key_bytes: Vec<u8>,
        cap_update_table: Vec<u8>,
    },

    /// Assigns tokens to a recipient account with proof verification
    /// @param token_issuer - The token issuer signer
    /// @param receiper - Recipient address
    /// @param proove - Proof data for verification
    /// @param amount - Amount of tokens to assign
    /// Requirements:
    /// - Valid proof must be provided
    /// - Sufficient balance must exist
    AssetMappingAssignToAccount {
        t: TypeTag,
        receiper: AccountAddress,
        proove: Vec<u8>,
        amount: u64,
    },

    /// Called by StarcoinNode after Genesis
    AssetMappingInitalizeProof {
        proof_root: Vec<u8>,
        anchor_height: u64,
    },

    CoinCreateCoinConversionMap {},

    /// Create STC pairing by passing `StarcoinCoin`.
    CoinCreatePairing {
        coin_type: TypeTag,
    },

    /// Voluntarily migrate to fungible store for `CoinType` if not yet.
    CoinMigrateToFungibleStore {
        coin_type: TypeTag,
    },

    /// Transfers `amount` of coins `CoinType` from `from` to `to`.
    CoinTransfer {
        coin_type: TypeTag,
        to: AccountAddress,
        amount: u64,
    },

    /// Upgrade total supply to use a parallelizable implementation if it is
    /// available.
    CoinUpgradeSupply {
        coin_type: TypeTag,
    },

    /// remove terminated proposal from proposer
    DaoDestroyTerminatedProposal {
        token_t: TypeTag,
        action_t: TypeTag,
        proposer_address: AccountAddress,
        proposal_id: u64,
    },

    /// queue agreed proposal to execute.
    DaoQueueProposalAction {
        token_t: TypeTag,
        action_t: TypeTag,
        proposer_address: AccountAddress,
        proposal_id: u64,
    },

    /// Once the proposal is agreed, anyone can call the method to make the proposal happen.
    DaoFeatuersProposalExecute {
        proposal_adderss: AccountAddress,
        proposal_id: u64,
    },

    DaoFeatuersProposalExecuteUrgent {
        enable: Vec<u64>,
        disable: Vec<u64>,
    },

    /// Entrypoint for the proposal.
    DaoFeatuersProposalPropose {
        enable: Vec<u64>,
        disable: Vec<u64>,
        exec_delay: u64,
    },

    /// Once the proposal is agreed, anyone can call the method to make the proposal happen.
    DaoModifyConfigProposalExecute {
        token_t: TypeTag,
        proposer_address: AccountAddress,
        proposal_id: u64,
    },

    /// Entrypoint for the proposal.
    DaoModifyConfigProposalPropose {
        token_t: TypeTag,
        voting_delay: u64,
        voting_period: u64,
        voting_quorum_rate: u8,
        min_action_delay: u64,
        exec_delay: u64,
    },

    DaoVoteScriptsCastVote {
        token: TypeTag,
        action_t: TypeTag,
        proposer_address: AccountAddress,
        proposal_id: u64,
        agree: bool,
        votes: u128,
    },

    /// Let user change their vote during the voting time.
    DaoVoteScriptsFlipVote {
        token_t: TypeTag,
        action_t: TypeTag,
        proposer_address: AccountAddress,
        proposal_id: u64,
    },

    /// revoke all votes on a proposal
    DaoVoteScriptsRevokeVote {
        token: TypeTag,
        action: TypeTag,
        proposer_address: AccountAddress,
        proposal_id: u64,
    },

    /// revoke some votes on a proposal
    DaoVoteScriptsRevokeVoteOfPower {
        token: TypeTag,
        action: TypeTag,
        proposer_address: AccountAddress,
        proposal_id: u64,
        power: u128,
    },

    DaoVoteScriptsUnstakeVote {
        token: TypeTag,
        action: TypeTag,
        proposer_address: AccountAddress,
        proposal_id: u64,
    },

    EasyGasScriptInitDataSource {
        token_type: TypeTag,
        init_value: u128,
    },

    EasyGasScriptRegister {
        token_type: TypeTag,
        precision: u8,
    },

    EasyGasScriptUpdate {
        token_type: TypeTag,
        value: u128,
    },

    EasyGasScriptWithdrawGasFeeEntry {
        token_type: TypeTag,
        amount: u128,
    },

    EmptyScriptsEmptyScript {},

    /// Withdraw an `amount` of coin `CoinType` from `account` and burn it.
    ManagedCoinBurn {
        coin_type: TypeTag,
        amount: u64,
    },

    /// Initialize new coin `CoinType` in Starcoin Blockchain.
    /// Mint and Burn Capabilities will be stored under `account` in `Capabilities` resource.
    ManagedCoinInitialize {
        coin_type: TypeTag,
        name: Vec<u8>,
        symbol: Vec<u8>,
        decimals: u8,
        monitor_supply: bool,
    },

    /// Create new coins `CoinType` and deposit them into dst_addr's account.
    ManagedCoinMint {
        coin_type: TypeTag,
        dst_addr: AccountAddress,
        amount: u64,
    },

    /// Creating a resource that stores balance of `CoinType` on user's account, withdraw and deposit event handlers.
    /// Required if user wants to start accepting deposits of `CoinType` in his account.
    ManagedCoinRegister {
        coin_type: TypeTag,
    },

    /// Entry function that can be used to transfer, if allow_ungated_transfer is set true.
    ObjectTransferCall {
        object: AccountAddress,
        to: AccountAddress,
    },

    OnChainConfigScriptsExecuteOnChainConfigProposal {
        config_t: TypeTag,
        proposal_id: u64,
    },

    OnChainConfigScriptsExecuteOnChainConfigProposalV2 {
        token_type: TypeTag,
        config_t: TypeTag,
        proposer_address: AccountAddress,
        proposal_id: u64,
    },

    OnChainConfigScriptsProposeUpdateConsensusConfig {
        uncle_rate_target: u64,
        base_block_time_target: u64,
        base_reward_per_block: u128,
        base_reward_per_uncle_percent: u64,
        epoch_block_count: u64,
        base_block_difficulty_window: u64,
        min_block_time_target: u64,
        max_block_time_target: u64,
        base_max_uncles_per_block: u64,
        base_block_gas_limit: u64,
        strategy: u8,
        exec_delay: u64,
    },

    OnChainConfigScriptsProposeUpdateFlexiDagEffectiveHeight {
        new_height: u64,
        exec_delay: u64,
    },

    OnChainConfigScriptsProposeUpdateMoveLanguageVersion {
        new_version: u64,
        exec_delay: u64,
    },

    OnChainConfigScriptsProposeUpdateRewardConfig {
        reward_delay: u64,
        exec_delay: u64,
    },

    /// Propose to update the transaction publish option.
    OnChainConfigScriptsProposeUpdateTxnPublishOption {
        script_allowed: bool,
        module_publishing_allowed: bool,
        exec_delay: u64,
    },

    /// Propose to update the transaction timeout configuration.
    OnChainConfigScriptsProposeUpdateTxnTimeoutConfig {
        duration_seconds: u64,
        exec_delay: u64,
    },

    /// Propose to update the VM configuration.
    OnChainConfigScriptsProposeUpdateVmConfig {
        new_config: Vec<u8>,
        exec_delay: u64,
    },

    OraclePriceInitDataSourceEntry {
        oracle_t: TypeTag,
        init_value: u128,
    },

    OraclePriceRegisterOracleEntry {
        oracle_t: TypeTag,
        precision: u8,
    },

    OraclePriceUpdateEntry {
        oracle_t: TypeTag,
        value: u128,
    },

    /// Creates a new resource account and rotates the authentication key to either
    /// the optional auth key if it is non-empty (though auth keys are 32-bytes)
    /// or the source accounts current auth key.
    ResourceAccountCreateResourceAccount {
        seed: Vec<u8>,
        optional_auth_key: Vec<u8>,
    },

    /// Creates a new resource account, transfer the amount of coins from the origin to the resource
    /// account, and rotates the authentication key to either the optional auth key if it is
    /// non-empty (though auth keys are 32-bytes) or the source accounts current auth key. Note,
    /// this function adds additional resource ownership to the resource account and should only be
    /// used for resource accounts that need access to `Coin<StarcoinCoin>`.
    ResourceAccountCreateResourceAccountAndFund {
        seed: Vec<u8>,
        optional_auth_key: Vec<u8>,
        fund_amount: u64,
    },

    /// Batch version of APT transfer.
    StarcoinAccountBatchTransfer {
        recipients: Vec<AccountAddress>,
        amounts: Vec<u64>,
    },

    /// Batch version of transfer_coins.
    StarcoinAccountBatchTransferCoins {
        coin_type: TypeTag,
        recipients: Vec<AccountAddress>,
        amounts: Vec<u64>,
    },

    /// Basic account creation methods.
    StarcoinAccountCreateAccount {
        auth_key: AccountAddress,
    },

    /// APT Primary Fungible Store specific specialized functions,
    /// Utilized internally once migration of APT to FungibleAsset is complete.
    /// Convenient function to transfer APT to a recipient account that might not exist.
    /// This would create the recipient APT PFS first, which also registers it to receive APT, before transferring.
    /// TODO: once migration is complete, rename to just "transfer_only" and make it an entry function (for cheapest way
    /// to transfer APT) - if we want to allow APT PFS without account itself
    StarcoinAccountFungibleTransferOnly {
        to: AccountAddress,
        amount: u64,
    },

    /// Set whether `account` can receive direct transfers of coins that they have not explicitly registered to receive.
    StarcoinAccountSetAllowDirectCoinTransfers {
        allow: bool,
    },

    /// Convenient function to transfer APT to a recipient account that might not exist.
    /// This would create the recipient account first, which also registers it to receive APT, before transferring.
    StarcoinAccountTransfer {
        to: AccountAddress,
        amount: u64,
    },

    /// Convenient function to transfer a custom CoinType to a recipient account that might not exist.
    /// This would create the recipient account first and register it to receive the CoinType, before transferring.
    StarcoinAccountTransferCoins {
        coin_type: TypeTag,
        to: AccountAddress,
        amount: u64,
    },

    /// Only callable in tests and testnets where the core resources account exists.
    /// Claim the delegated mint capability and destroy the delegated token.
    StarcoinCoinClaimMintCapability {},

    /// Only callable in tests and testnets where the core resources account exists.
    /// Create delegated token for the address so the account could claim MintCapability later.
    StarcoinCoinDelegateMintCapability {
        to: AccountAddress,
    },

    /// Only callable in tests and testnets where the core resources account exists.
    /// Create new coins and deposit them into dst_addr's account.
    StarcoinCoinMint {
        dst_addr: AccountAddress,
        amount: u64,
    },

    StcGenesisInitialize {
        stdlib_version: u64,
        reward_delay: u64,
        total_stc_amount: u128,
        pre_mine_stc_amount: u128,
        time_mint_stc_amount: u128,
        time_mint_stc_period: u64,
        parent_hash: Vec<u8>,
        association_auth_key: Vec<u8>,
        genesis_auth_key: Vec<u8>,
        chain_id: u8,
        _genesis_timestamp: u64,
        uncle_rate_target: u64,
        epoch_block_count: u64,
        base_block_time_target: u64,
        base_block_difficulty_window: u64,
        base_reward_per_block: u128,
        base_reward_per_uncle_percent: u64,
        min_block_time_target: u64,
        max_block_time_target: u64,
        base_max_uncles_per_block: u64,
        base_block_gas_limit: u64,
        strategy: u8,
        script_allowed: bool,
        module_publishing_allowed: bool,
        gas_schedule_blob: Vec<u8>,
        voting_delay: u64,
        voting_period: u64,
        voting_quorum_rate: u8,
        min_action_delay: u64,
        transaction_timeout: u64,
        dag_effective_height: u64,
        features: Vec<u8>,
    },

    /// Batch transfer token to others.
    TransferScriptsBatchPeerToPeer {
        token_type: TypeTag,
        payeees: Vec<AccountAddress>,
        _payee_auth_keys: Vec<Vec<u8>>,
        amounts: Vec<u128>,
    },

    /// Batch transfer token to others.
    TransferScriptsBatchPeerToPeerV2 {
        token_type: TypeTag,
        payeees: Vec<AccountAddress>,
        amounts: Vec<u128>,
    },

    TransferScriptsPeerToPeer {
        token_type: TypeTag,
        payee: AccountAddress,
        _payee_auth_key: Vec<u8>,
        amount: u128,
    },

    TransferScriptsPeerToPeerV2 {
        token_type: TypeTag,
        payee: AccountAddress,
        amount: u128,
    },

    /// Execute a withdraw proposal.
    TreasuryScriptsExecuteWithdrawProposal {
        token_t: TypeTag,
        proposer_address: AccountAddress,
        proposal_id: u64,
    },

    /// Propose a withdraw from treasury.
    TreasuryScriptsProposeWithdraw {
        token_t: TypeTag,
        receiver: AccountAddress,
        amount: u128,
        period: u64,
        exec_delay: u64,
    },

    /// Withdraw token from treasury and split the LinearWithdrawCapability.
    TreasuryScriptsWithdrawAndSplitLtWithdrawCap {
        token_t: TypeTag,
        for_address: AccountAddress,
        amount: u128,
        lock_period: u64,
    },

    /// Withdraw token from treasury.
    TreasuryScriptsWithdrawTokenWithLinearWithdrawCapability {
        token_t: TypeTag,
    },
}

impl EntryFunctionCall {
    /// Build an Starcoin `TransactionPayload` from a structured object `EntryFunctionCall`.
    pub fn encode(self) -> TransactionPayload {
        use EntryFunctionCall::*;
        match self {
            AccountOfferRotationCapability {
                rotation_capability_sig_bytes,
                account_scheme,
                account_public_key_bytes,
                recipient_address,
            } => account_offer_rotation_capability(
                rotation_capability_sig_bytes,
                account_scheme,
                account_public_key_bytes,
                recipient_address,
            ),
            AccountOfferSignerCapability {
                signer_capability_sig_bytes,
                account_scheme,
                account_public_key_bytes,
                recipient_address,
            } => account_offer_signer_capability(
                signer_capability_sig_bytes,
                account_scheme,
                account_public_key_bytes,
                recipient_address,
            ),
            AccountRevokeAnyRotationCapability {} => account_revoke_any_rotation_capability(),
            AccountRevokeAnySignerCapability {} => account_revoke_any_signer_capability(),
            AccountRevokeRotationCapability {
                to_be_revoked_address,
            } => account_revoke_rotation_capability(to_be_revoked_address),
            AccountRevokeSignerCapability {
                to_be_revoked_address,
            } => account_revoke_signer_capability(to_be_revoked_address),
            AccountRotateAuthenticationKey {
                from_scheme,
                from_public_key_bytes,
                to_scheme,
                to_public_key_bytes,
                cap_rotate_key,
                cap_update_table,
            } => account_rotate_authentication_key(
                from_scheme,
                from_public_key_bytes,
                to_scheme,
                to_public_key_bytes,
                cap_rotate_key,
                cap_update_table,
            ),
            AccountRotateAuthenticationKeyCall { new_auth_key } => {
                account_rotate_authentication_key_call(new_auth_key)
            }
            AccountRotateAuthenticationKeyWithRotationCapability {
                rotation_cap_offerer_address,
                new_scheme,
                new_public_key_bytes,
                cap_update_table,
            } => account_rotate_authentication_key_with_rotation_capability(
                rotation_cap_offerer_address,
                new_scheme,
                new_public_key_bytes,
                cap_update_table,
            ),
            AssetMappingAssignToAccount {
                t,
                receiper,
                proove,
                amount,
            } => asset_mapping_assign_to_account(t, receiper, proove, amount),
            AssetMappingInitalizeProof {
                proof_root,
                anchor_height,
            } => asset_mapping_initalize_proof(proof_root, anchor_height),
            CoinCreateCoinConversionMap {} => coin_create_coin_conversion_map(),
            CoinCreatePairing { coin_type } => coin_create_pairing(coin_type),
            CoinMigrateToFungibleStore { coin_type } => coin_migrate_to_fungible_store(coin_type),
            CoinTransfer {
                coin_type,
                to,
                amount,
            } => coin_transfer(coin_type, to, amount),
            CoinUpgradeSupply { coin_type } => coin_upgrade_supply(coin_type),
            DaoDestroyTerminatedProposal {
                token_t,
                action_t,
                proposer_address,
                proposal_id,
            } => dao_destroy_terminated_proposal(token_t, action_t, proposer_address, proposal_id),
            DaoQueueProposalAction {
                token_t,
                action_t,
                proposer_address,
                proposal_id,
            } => dao_queue_proposal_action(token_t, action_t, proposer_address, proposal_id),
            DaoFeatuersProposalExecute {
                proposal_adderss,
                proposal_id,
            } => dao_featuers_proposal_execute(proposal_adderss, proposal_id),
            DaoFeatuersProposalExecuteUrgent { enable, disable } => {
                dao_featuers_proposal_execute_urgent(enable, disable)
            }
            DaoFeatuersProposalPropose {
                enable,
                disable,
                exec_delay,
            } => dao_featuers_proposal_propose(enable, disable, exec_delay),
            DaoModifyConfigProposalExecute {
                token_t,
                proposer_address,
                proposal_id,
            } => dao_modify_config_proposal_execute(token_t, proposer_address, proposal_id),
            DaoModifyConfigProposalPropose {
                token_t,
                voting_delay,
                voting_period,
                voting_quorum_rate,
                min_action_delay,
                exec_delay,
            } => dao_modify_config_proposal_propose(
                token_t,
                voting_delay,
                voting_period,
                voting_quorum_rate,
                min_action_delay,
                exec_delay,
            ),
            DaoVoteScriptsCastVote {
                token,
                action_t,
                proposer_address,
                proposal_id,
                agree,
                votes,
            } => dao_vote_scripts_cast_vote(
                token,
                action_t,
                proposer_address,
                proposal_id,
                agree,
                votes,
            ),
            DaoVoteScriptsFlipVote {
                token_t,
                action_t,
                proposer_address,
                proposal_id,
            } => dao_vote_scripts_flip_vote(token_t, action_t, proposer_address, proposal_id),
            DaoVoteScriptsRevokeVote {
                token,
                action,
                proposer_address,
                proposal_id,
            } => dao_vote_scripts_revoke_vote(token, action, proposer_address, proposal_id),
            DaoVoteScriptsRevokeVoteOfPower {
                token,
                action,
                proposer_address,
                proposal_id,
                power,
            } => dao_vote_scripts_revoke_vote_of_power(
                token,
                action,
                proposer_address,
                proposal_id,
                power,
            ),
            DaoVoteScriptsUnstakeVote {
                token,
                action,
                proposer_address,
                proposal_id,
            } => dao_vote_scripts_unstake_vote(token, action, proposer_address, proposal_id),
            EasyGasScriptInitDataSource {
                token_type,
                init_value,
            } => easy_gas_script_init_data_source(token_type, init_value),
            EasyGasScriptRegister {
                token_type,
                precision,
            } => easy_gas_script_register(token_type, precision),
            EasyGasScriptUpdate { token_type, value } => easy_gas_script_update(token_type, value),
            EasyGasScriptWithdrawGasFeeEntry { token_type, amount } => {
                easy_gas_script_withdraw_gas_fee_entry(token_type, amount)
            }
            EmptyScriptsEmptyScript {} => empty_scripts_empty_script(),
            ManagedCoinBurn { coin_type, amount } => managed_coin_burn(coin_type, amount),
            ManagedCoinInitialize {
                coin_type,
                name,
                symbol,
                decimals,
                monitor_supply,
            } => managed_coin_initialize(coin_type, name, symbol, decimals, monitor_supply),
            ManagedCoinMint {
                coin_type,
                dst_addr,
                amount,
            } => managed_coin_mint(coin_type, dst_addr, amount),
            ManagedCoinRegister { coin_type } => managed_coin_register(coin_type),
            ObjectTransferCall { object, to } => object_transfer_call(object, to),
            OnChainConfigScriptsExecuteOnChainConfigProposal {
                config_t,
                proposal_id,
            } => on_chain_config_scripts_execute_on_chain_config_proposal(config_t, proposal_id),
            OnChainConfigScriptsExecuteOnChainConfigProposalV2 {
                token_type,
                config_t,
                proposer_address,
                proposal_id,
            } => on_chain_config_scripts_execute_on_chain_config_proposal_v2(
                token_type,
                config_t,
                proposer_address,
                proposal_id,
            ),
            OnChainConfigScriptsProposeUpdateConsensusConfig {
                uncle_rate_target,
                base_block_time_target,
                base_reward_per_block,
                base_reward_per_uncle_percent,
                epoch_block_count,
                base_block_difficulty_window,
                min_block_time_target,
                max_block_time_target,
                base_max_uncles_per_block,
                base_block_gas_limit,
                strategy,
                exec_delay,
            } => on_chain_config_scripts_propose_update_consensus_config(
                uncle_rate_target,
                base_block_time_target,
                base_reward_per_block,
                base_reward_per_uncle_percent,
                epoch_block_count,
                base_block_difficulty_window,
                min_block_time_target,
                max_block_time_target,
                base_max_uncles_per_block,
                base_block_gas_limit,
                strategy,
                exec_delay,
            ),
            OnChainConfigScriptsProposeUpdateFlexiDagEffectiveHeight {
                new_height,
                exec_delay,
            } => on_chain_config_scripts_propose_update_flexi_dag_effective_height(
                new_height, exec_delay,
            ),
            OnChainConfigScriptsProposeUpdateMoveLanguageVersion {
                new_version,
                exec_delay,
            } => on_chain_config_scripts_propose_update_move_language_version(
                new_version,
                exec_delay,
            ),
            OnChainConfigScriptsProposeUpdateRewardConfig {
                reward_delay,
                exec_delay,
            } => on_chain_config_scripts_propose_update_reward_config(reward_delay, exec_delay),
            OnChainConfigScriptsProposeUpdateTxnPublishOption {
                script_allowed,
                module_publishing_allowed,
                exec_delay,
            } => on_chain_config_scripts_propose_update_txn_publish_option(
                script_allowed,
                module_publishing_allowed,
                exec_delay,
            ),
            OnChainConfigScriptsProposeUpdateTxnTimeoutConfig {
                duration_seconds,
                exec_delay,
            } => on_chain_config_scripts_propose_update_txn_timeout_config(
                duration_seconds,
                exec_delay,
            ),
            OnChainConfigScriptsProposeUpdateVmConfig {
                new_config,
                exec_delay,
            } => on_chain_config_scripts_propose_update_vm_config(new_config, exec_delay),
            OraclePriceInitDataSourceEntry {
                oracle_t,
                init_value,
            } => oracle_price_init_data_source_entry(oracle_t, init_value),
            OraclePriceRegisterOracleEntry {
                oracle_t,
                precision,
            } => oracle_price_register_oracle_entry(oracle_t, precision),
            OraclePriceUpdateEntry { oracle_t, value } => {
                oracle_price_update_entry(oracle_t, value)
            }
            ResourceAccountCreateResourceAccount {
                seed,
                optional_auth_key,
            } => resource_account_create_resource_account(seed, optional_auth_key),
            ResourceAccountCreateResourceAccountAndFund {
                seed,
                optional_auth_key,
                fund_amount,
            } => resource_account_create_resource_account_and_fund(
                seed,
                optional_auth_key,
                fund_amount,
            ),
            StarcoinAccountBatchTransfer {
                recipients,
                amounts,
            } => starcoin_account_batch_transfer(recipients, amounts),
            StarcoinAccountBatchTransferCoins {
                coin_type,
                recipients,
                amounts,
            } => starcoin_account_batch_transfer_coins(coin_type, recipients, amounts),
            StarcoinAccountCreateAccount { auth_key } => starcoin_account_create_account(auth_key),
            StarcoinAccountFungibleTransferOnly { to, amount } => {
                starcoin_account_fungible_transfer_only(to, amount)
            }
            StarcoinAccountSetAllowDirectCoinTransfers { allow } => {
                starcoin_account_set_allow_direct_coin_transfers(allow)
            }
            StarcoinAccountTransfer { to, amount } => starcoin_account_transfer(to, amount),
            StarcoinAccountTransferCoins {
                coin_type,
                to,
                amount,
            } => starcoin_account_transfer_coins(coin_type, to, amount),
            StarcoinCoinClaimMintCapability {} => starcoin_coin_claim_mint_capability(),
            StarcoinCoinDelegateMintCapability { to } => starcoin_coin_delegate_mint_capability(to),
            StarcoinCoinMint { dst_addr, amount } => starcoin_coin_mint(dst_addr, amount),
            StcGenesisInitialize {
                stdlib_version,
                reward_delay,
                total_stc_amount,
                pre_mine_stc_amount,
                time_mint_stc_amount,
                time_mint_stc_period,
                parent_hash,
                association_auth_key,
                genesis_auth_key,
                chain_id,
                _genesis_timestamp,
                uncle_rate_target,
                epoch_block_count,
                base_block_time_target,
                base_block_difficulty_window,
                base_reward_per_block,
                base_reward_per_uncle_percent,
                min_block_time_target,
                max_block_time_target,
                base_max_uncles_per_block,
                base_block_gas_limit,
                strategy,
                script_allowed,
                module_publishing_allowed,
                gas_schedule_blob,
                voting_delay,
                voting_period,
                voting_quorum_rate,
                min_action_delay,
                transaction_timeout,
                dag_effective_height,
                features,
            } => stc_genesis_initialize(
                stdlib_version,
                reward_delay,
                total_stc_amount,
                pre_mine_stc_amount,
                time_mint_stc_amount,
                time_mint_stc_period,
                parent_hash,
                association_auth_key,
                genesis_auth_key,
                chain_id,
                _genesis_timestamp,
                uncle_rate_target,
                epoch_block_count,
                base_block_time_target,
                base_block_difficulty_window,
                base_reward_per_block,
                base_reward_per_uncle_percent,
                min_block_time_target,
                max_block_time_target,
                base_max_uncles_per_block,
                base_block_gas_limit,
                strategy,
                script_allowed,
                module_publishing_allowed,
                gas_schedule_blob,
                voting_delay,
                voting_period,
                voting_quorum_rate,
                min_action_delay,
                transaction_timeout,
                dag_effective_height,
                features,
            ),
            TransferScriptsBatchPeerToPeer {
                token_type,
                payeees,
                _payee_auth_keys,
                amounts,
            } => {
                transfer_scripts_batch_peer_to_peer(token_type, payeees, _payee_auth_keys, amounts)
            }
            TransferScriptsBatchPeerToPeerV2 {
                token_type,
                payeees,
                amounts,
            } => transfer_scripts_batch_peer_to_peer_v2(token_type, payeees, amounts),
            TransferScriptsPeerToPeer {
                token_type,
                payee,
                _payee_auth_key,
                amount,
            } => transfer_scripts_peer_to_peer(token_type, payee, _payee_auth_key, amount),
            TransferScriptsPeerToPeerV2 {
                token_type,
                payee,
                amount,
            } => transfer_scripts_peer_to_peer_v2(token_type, payee, amount),
            TreasuryScriptsExecuteWithdrawProposal {
                token_t,
                proposer_address,
                proposal_id,
            } => treasury_scripts_execute_withdraw_proposal(token_t, proposer_address, proposal_id),
            TreasuryScriptsProposeWithdraw {
                token_t,
                receiver,
                amount,
                period,
                exec_delay,
            } => treasury_scripts_propose_withdraw(token_t, receiver, amount, period, exec_delay),
            TreasuryScriptsWithdrawAndSplitLtWithdrawCap {
                token_t,
                for_address,
                amount,
                lock_period,
            } => treasury_scripts_withdraw_and_split_lt_withdraw_cap(
                token_t,
                for_address,
                amount,
                lock_period,
            ),
            TreasuryScriptsWithdrawTokenWithLinearWithdrawCapability { token_t } => {
                treasury_scripts_withdraw_token_with_linear_withdraw_capability(token_t)
            }
        }
    }

    /// Try to recognize an Starcoin `TransactionPayload` and convert it into a structured object `EntryFunctionCall`.
    pub fn decode(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            match SCRIPT_FUNCTION_DECODER_MAP.get(&format!(
                "{}_{}",
                script.module().name(),
                script.function()
            )) {
                Some(decoder) => decoder(payload),
                None => None,
            }
        } else {
            None
        }
    }
}

/// Offers rotation capability on behalf of `account` to the account at address `recipient_address`.
/// An account can delegate its rotation capability to only one other address at one time. If the account
/// has an existing rotation capability offer, calling this function will update the rotation capability offer with
/// the new `recipient_address`.
/// Here, `rotation_capability_sig_bytes` signature indicates that this key rotation is authorized by the account owner,
/// and prevents the classic "time-of-check time-of-use" attack.
/// For example, users usually rely on what the wallet displays to them as the transaction's outcome. Consider a contract that with 50% probability
/// (based on the current timestamp in Move), rotates somebody's key. The wallet might be unlucky and get an outcome where nothing is rotated,
/// incorrectly telling the user nothing bad will happen. But when the transaction actually gets executed, the attacker gets lucky and
/// the execution path triggers the account key rotation.
/// We prevent such attacks by asking for this extra signature authorizing the key rotation.
///
/// @param rotation_capability_sig_bytes is the signature by the account owner's key on `RotationCapabilityOfferProofChallengeV2`.
/// @param account_scheme is the scheme of the account (ed25519 or multi_ed25519).
/// @param account_public_key_bytes is the public key of the account owner.
/// @param recipient_address is the address of the recipient of the rotation capability - note that if there's an existing rotation capability
/// offer, calling this function will replace the previous `recipient_address` upon successful verification.
pub fn account_offer_rotation_capability(
    rotation_capability_sig_bytes: Vec<u8>,
    account_scheme: u8,
    account_public_key_bytes: Vec<u8>,
    recipient_address: AccountAddress,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("account").to_owned(),
        ),
        ident_str!("offer_rotation_capability").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&rotation_capability_sig_bytes).unwrap(),
            bcs::to_bytes(&account_scheme).unwrap(),
            bcs::to_bytes(&account_public_key_bytes).unwrap(),
            bcs::to_bytes(&recipient_address).unwrap(),
        ],
    ))
}

/// Offers signer capability on behalf of `account` to the account at address `recipient_address`.
/// An account can delegate its signer capability to only one other address at one time.
/// `signer_capability_key_bytes` is the `SignerCapabilityOfferProofChallengeV2` signed by the account owner's key
/// `account_scheme` is the scheme of the account (ed25519 or multi_ed25519).
/// `account_public_key_bytes` is the public key of the account owner.
/// `recipient_address` is the address of the recipient of the signer capability - note that if there's an existing
/// `recipient_address` in the account owner's `SignerCapabilityOffer`, this will replace the
/// previous `recipient_address` upon successful verification (the previous recipient will no longer have access
/// to the account owner's signer capability).
pub fn account_offer_signer_capability(
    signer_capability_sig_bytes: Vec<u8>,
    account_scheme: u8,
    account_public_key_bytes: Vec<u8>,
    recipient_address: AccountAddress,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("account").to_owned(),
        ),
        ident_str!("offer_signer_capability").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&signer_capability_sig_bytes).unwrap(),
            bcs::to_bytes(&account_scheme).unwrap(),
            bcs::to_bytes(&account_public_key_bytes).unwrap(),
            bcs::to_bytes(&recipient_address).unwrap(),
        ],
    ))
}

/// Revoke any rotation capability offer in the specified account.
pub fn account_revoke_any_rotation_capability() -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("account").to_owned(),
        ),
        ident_str!("revoke_any_rotation_capability").to_owned(),
        vec![],
        vec![],
    ))
}

/// Revoke any signer capability offer in the specified account.
pub fn account_revoke_any_signer_capability() -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("account").to_owned(),
        ),
        ident_str!("revoke_any_signer_capability").to_owned(),
        vec![],
        vec![],
    ))
}

/// Revoke the rotation capability offer given to `to_be_revoked_recipient_address` from `account`
pub fn account_revoke_rotation_capability(
    to_be_revoked_address: AccountAddress,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("account").to_owned(),
        ),
        ident_str!("revoke_rotation_capability").to_owned(),
        vec![],
        vec![bcs::to_bytes(&to_be_revoked_address).unwrap()],
    ))
}

/// Revoke the account owner's signer capability offer for `to_be_revoked_address` (i.e., the address that
/// has a signer capability offer from `account` but will be revoked in this function).
pub fn account_revoke_signer_capability(
    to_be_revoked_address: AccountAddress,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("account").to_owned(),
        ),
        ident_str!("revoke_signer_capability").to_owned(),
        vec![],
        vec![bcs::to_bytes(&to_be_revoked_address).unwrap()],
    ))
}

/// Generic authentication key rotation function that allows the user to rotate their authentication key from any scheme to any scheme.
/// To authorize the rotation, we need two signatures:
/// - the first signature `cap_rotate_key` refers to the signature by the account owner's current key on a valid `RotationProofChallenge`,
/// demonstrating that the user intends to and has the capability to rotate the authentication key of this account;
/// - the second signature `cap_update_table` refers to the signature by the new key (that the account owner wants to rotate to) on a
/// valid `RotationProofChallenge`, demonstrating that the user owns the new private key, and has the authority to update the
/// `OriginatingAddress` map with the new address mapping `<new_address, originating_address>`.
/// To verify these two signatures, we need their corresponding public key and public key scheme: we use `from_scheme` and `from_public_key_bytes`
/// to verify `cap_rotate_key`, and `to_scheme` and `to_public_key_bytes` to verify `cap_update_table`.
/// A scheme of 0 refers to an Ed25519 key and a scheme of 1 refers to Multi-Ed25519 keys.
/// `originating address` refers to an account's original/first address.
///
/// Here is an example attack if we don't ask for the second signature `cap_update_table`:
/// Alice has rotated her account `addr_a` to `new_addr_a`. As a result, the following entry is created, to help Alice when recovering her wallet:
/// `OriginatingAddress[new_addr_a]` -> `addr_a`
/// Alice has had a bad day: her laptop blew up and she needs to reset her account on a new one.
/// (Fortunately, she still has her secret key `new_sk_a` associated with her new address `new_addr_a`, so she can do this.)
///
/// But Bob likes to mess with Alice.
/// Bob creates an account `addr_b` and maliciously rotates it to Alice's new address `new_addr_a`. Since we are no longer checking a PoK,
/// Bob can easily do this.
///
/// Now, the table will be updated to make Alice's new address point to Bob's address: `OriginatingAddress[new_addr_a]` -> `addr_b`.
/// When Alice recovers her account, her wallet will display the attacker's address (Bob's) `addr_b` as her address.
/// Now Alice will give `addr_b` to everyone to pay her, but the money will go to Bob.
///
/// Because we ask for a valid `cap_update_table`, this kind of attack is not possible. Bob would not have the secret key of Alice's address
/// to rotate his address to Alice's address in the first place.
pub fn account_rotate_authentication_key(
    from_scheme: u8,
    from_public_key_bytes: Vec<u8>,
    to_scheme: u8,
    to_public_key_bytes: Vec<u8>,
    cap_rotate_key: Vec<u8>,
    cap_update_table: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("account").to_owned(),
        ),
        ident_str!("rotate_authentication_key").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&from_scheme).unwrap(),
            bcs::to_bytes(&from_public_key_bytes).unwrap(),
            bcs::to_bytes(&to_scheme).unwrap(),
            bcs::to_bytes(&to_public_key_bytes).unwrap(),
            bcs::to_bytes(&cap_rotate_key).unwrap(),
            bcs::to_bytes(&cap_update_table).unwrap(),
        ],
    ))
}

/// Private entry function for key rotation that allows the signer to update their authentication key.
/// Note that this does not update the `OriginatingAddress` table because the `new_auth_key` is not "verified": it
/// does not come with a proof-of-knowledge of the underlying SK. Nonetheless, we need this functionality due to
/// the introduction of non-standard key algorithms, such as passkeys, which cannot produce proofs-of-knowledge in
/// the format expected in `rotate_authentication_key`.
pub fn account_rotate_authentication_key_call(new_auth_key: Vec<u8>) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("account").to_owned(),
        ),
        ident_str!("rotate_authentication_key_call").to_owned(),
        vec![],
        vec![bcs::to_bytes(&new_auth_key).unwrap()],
    ))
}

pub fn account_rotate_authentication_key_with_rotation_capability(
    rotation_cap_offerer_address: AccountAddress,
    new_scheme: u8,
    new_public_key_bytes: Vec<u8>,
    cap_update_table: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("account").to_owned(),
        ),
        ident_str!("rotate_authentication_key_with_rotation_capability").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&rotation_cap_offerer_address).unwrap(),
            bcs::to_bytes(&new_scheme).unwrap(),
            bcs::to_bytes(&new_public_key_bytes).unwrap(),
            bcs::to_bytes(&cap_update_table).unwrap(),
        ],
    ))
}

/// Assigns tokens to a recipient account with proof verification
/// @param token_issuer - The token issuer signer
/// @param receiper - Recipient address
/// @param proove - Proof data for verification
/// @param amount - Amount of tokens to assign
/// Requirements:
/// - Valid proof must be provided
/// - Sufficient balance must exist
pub fn asset_mapping_assign_to_account(
    t: TypeTag,
    receiper: AccountAddress,
    proove: Vec<u8>,
    amount: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("asset_mapping").to_owned(),
        ),
        ident_str!("assign_to_account").to_owned(),
        vec![t],
        vec![
            bcs::to_bytes(&receiper).unwrap(),
            bcs::to_bytes(&proove).unwrap(),
            bcs::to_bytes(&amount).unwrap(),
        ],
    ))
}

/// Called by StarcoinNode after Genesis
pub fn asset_mapping_initalize_proof(
    proof_root: Vec<u8>,
    anchor_height: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("asset_mapping").to_owned(),
        ),
        ident_str!("initalize_proof").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&proof_root).unwrap(),
            bcs::to_bytes(&anchor_height).unwrap(),
        ],
    ))
}

pub fn coin_create_coin_conversion_map() -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("coin").to_owned(),
        ),
        ident_str!("create_coin_conversion_map").to_owned(),
        vec![],
        vec![],
    ))
}

/// Create STC pairing by passing `StarcoinCoin`.
pub fn coin_create_pairing(coin_type: TypeTag) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("coin").to_owned(),
        ),
        ident_str!("create_pairing").to_owned(),
        vec![coin_type],
        vec![],
    ))
}

/// Voluntarily migrate to fungible store for `CoinType` if not yet.
pub fn coin_migrate_to_fungible_store(coin_type: TypeTag) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("coin").to_owned(),
        ),
        ident_str!("migrate_to_fungible_store").to_owned(),
        vec![coin_type],
        vec![],
    ))
}

/// Transfers `amount` of coins `CoinType` from `from` to `to`.
pub fn coin_transfer(coin_type: TypeTag, to: AccountAddress, amount: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("coin").to_owned(),
        ),
        ident_str!("transfer").to_owned(),
        vec![coin_type],
        vec![bcs::to_bytes(&to).unwrap(), bcs::to_bytes(&amount).unwrap()],
    ))
}

/// Upgrade total supply to use a parallelizable implementation if it is
/// available.
pub fn coin_upgrade_supply(coin_type: TypeTag) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("coin").to_owned(),
        ),
        ident_str!("upgrade_supply").to_owned(),
        vec![coin_type],
        vec![],
    ))
}

/// remove terminated proposal from proposer
pub fn dao_destroy_terminated_proposal(
    token_t: TypeTag,
    action_t: TypeTag,
    proposer_address: AccountAddress,
    proposal_id: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("dao").to_owned(),
        ),
        ident_str!("destroy_terminated_proposal").to_owned(),
        vec![token_t, action_t],
        vec![
            bcs::to_bytes(&proposer_address).unwrap(),
            bcs::to_bytes(&proposal_id).unwrap(),
        ],
    ))
}

/// queue agreed proposal to execute.
pub fn dao_queue_proposal_action(
    token_t: TypeTag,
    action_t: TypeTag,
    proposer_address: AccountAddress,
    proposal_id: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("dao").to_owned(),
        ),
        ident_str!("queue_proposal_action").to_owned(),
        vec![token_t, action_t],
        vec![
            bcs::to_bytes(&proposer_address).unwrap(),
            bcs::to_bytes(&proposal_id).unwrap(),
        ],
    ))
}

/// Once the proposal is agreed, anyone can call the method to make the proposal happen.
pub fn dao_featuers_proposal_execute(
    proposal_adderss: AccountAddress,
    proposal_id: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("dao_featuers_proposal").to_owned(),
        ),
        ident_str!("execute").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&proposal_adderss).unwrap(),
            bcs::to_bytes(&proposal_id).unwrap(),
        ],
    ))
}

pub fn dao_featuers_proposal_execute_urgent(
    enable: Vec<u64>,
    disable: Vec<u64>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("dao_featuers_proposal").to_owned(),
        ),
        ident_str!("execute_urgent").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&enable).unwrap(),
            bcs::to_bytes(&disable).unwrap(),
        ],
    ))
}

/// Entrypoint for the proposal.
pub fn dao_featuers_proposal_propose(
    enable: Vec<u64>,
    disable: Vec<u64>,
    exec_delay: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("dao_featuers_proposal").to_owned(),
        ),
        ident_str!("propose").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&enable).unwrap(),
            bcs::to_bytes(&disable).unwrap(),
            bcs::to_bytes(&exec_delay).unwrap(),
        ],
    ))
}

/// Once the proposal is agreed, anyone can call the method to make the proposal happen.
pub fn dao_modify_config_proposal_execute(
    token_t: TypeTag,
    proposer_address: AccountAddress,
    proposal_id: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("dao_modify_config_proposal").to_owned(),
        ),
        ident_str!("execute").to_owned(),
        vec![token_t],
        vec![
            bcs::to_bytes(&proposer_address).unwrap(),
            bcs::to_bytes(&proposal_id).unwrap(),
        ],
    ))
}

/// Entrypoint for the proposal.
pub fn dao_modify_config_proposal_propose(
    token_t: TypeTag,
    voting_delay: u64,
    voting_period: u64,
    voting_quorum_rate: u8,
    min_action_delay: u64,
    exec_delay: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("dao_modify_config_proposal").to_owned(),
        ),
        ident_str!("propose").to_owned(),
        vec![token_t],
        vec![
            bcs::to_bytes(&voting_delay).unwrap(),
            bcs::to_bytes(&voting_period).unwrap(),
            bcs::to_bytes(&voting_quorum_rate).unwrap(),
            bcs::to_bytes(&min_action_delay).unwrap(),
            bcs::to_bytes(&exec_delay).unwrap(),
        ],
    ))
}

pub fn dao_vote_scripts_cast_vote(
    token: TypeTag,
    action_t: TypeTag,
    proposer_address: AccountAddress,
    proposal_id: u64,
    agree: bool,
    votes: u128,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("dao_vote_scripts").to_owned(),
        ),
        ident_str!("cast_vote").to_owned(),
        vec![token, action_t],
        vec![
            bcs::to_bytes(&proposer_address).unwrap(),
            bcs::to_bytes(&proposal_id).unwrap(),
            bcs::to_bytes(&agree).unwrap(),
            bcs::to_bytes(&votes).unwrap(),
        ],
    ))
}

/// Let user change their vote during the voting time.
pub fn dao_vote_scripts_flip_vote(
    token_t: TypeTag,
    action_t: TypeTag,
    proposer_address: AccountAddress,
    proposal_id: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("dao_vote_scripts").to_owned(),
        ),
        ident_str!("flip_vote").to_owned(),
        vec![token_t, action_t],
        vec![
            bcs::to_bytes(&proposer_address).unwrap(),
            bcs::to_bytes(&proposal_id).unwrap(),
        ],
    ))
}

/// revoke all votes on a proposal
pub fn dao_vote_scripts_revoke_vote(
    token: TypeTag,
    action: TypeTag,
    proposer_address: AccountAddress,
    proposal_id: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("dao_vote_scripts").to_owned(),
        ),
        ident_str!("revoke_vote").to_owned(),
        vec![token, action],
        vec![
            bcs::to_bytes(&proposer_address).unwrap(),
            bcs::to_bytes(&proposal_id).unwrap(),
        ],
    ))
}

/// revoke some votes on a proposal
pub fn dao_vote_scripts_revoke_vote_of_power(
    token: TypeTag,
    action: TypeTag,
    proposer_address: AccountAddress,
    proposal_id: u64,
    power: u128,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("dao_vote_scripts").to_owned(),
        ),
        ident_str!("revoke_vote_of_power").to_owned(),
        vec![token, action],
        vec![
            bcs::to_bytes(&proposer_address).unwrap(),
            bcs::to_bytes(&proposal_id).unwrap(),
            bcs::to_bytes(&power).unwrap(),
        ],
    ))
}

pub fn dao_vote_scripts_unstake_vote(
    token: TypeTag,
    action: TypeTag,
    proposer_address: AccountAddress,
    proposal_id: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("dao_vote_scripts").to_owned(),
        ),
        ident_str!("unstake_vote").to_owned(),
        vec![token, action],
        vec![
            bcs::to_bytes(&proposer_address).unwrap(),
            bcs::to_bytes(&proposal_id).unwrap(),
        ],
    ))
}

pub fn easy_gas_script_init_data_source(
    token_type: TypeTag,
    init_value: u128,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("easy_gas_script").to_owned(),
        ),
        ident_str!("init_data_source").to_owned(),
        vec![token_type],
        vec![bcs::to_bytes(&init_value).unwrap()],
    ))
}

pub fn easy_gas_script_register(token_type: TypeTag, precision: u8) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("easy_gas_script").to_owned(),
        ),
        ident_str!("register").to_owned(),
        vec![token_type],
        vec![bcs::to_bytes(&precision).unwrap()],
    ))
}

pub fn easy_gas_script_update(token_type: TypeTag, value: u128) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("easy_gas_script").to_owned(),
        ),
        ident_str!("update").to_owned(),
        vec![token_type],
        vec![bcs::to_bytes(&value).unwrap()],
    ))
}

pub fn easy_gas_script_withdraw_gas_fee_entry(
    token_type: TypeTag,
    amount: u128,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("easy_gas_script").to_owned(),
        ),
        ident_str!("withdraw_gas_fee_entry").to_owned(),
        vec![token_type],
        vec![bcs::to_bytes(&amount).unwrap()],
    ))
}

pub fn empty_scripts_empty_script() -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("empty_scripts").to_owned(),
        ),
        ident_str!("empty_script").to_owned(),
        vec![],
        vec![],
    ))
}

/// Withdraw an `amount` of coin `CoinType` from `account` and burn it.
pub fn managed_coin_burn(coin_type: TypeTag, amount: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("managed_coin").to_owned(),
        ),
        ident_str!("burn").to_owned(),
        vec![coin_type],
        vec![bcs::to_bytes(&amount).unwrap()],
    ))
}

/// Initialize new coin `CoinType` in Starcoin Blockchain.
/// Mint and Burn Capabilities will be stored under `account` in `Capabilities` resource.
pub fn managed_coin_initialize(
    coin_type: TypeTag,
    name: Vec<u8>,
    symbol: Vec<u8>,
    decimals: u8,
    monitor_supply: bool,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("managed_coin").to_owned(),
        ),
        ident_str!("initialize").to_owned(),
        vec![coin_type],
        vec![
            bcs::to_bytes(&name).unwrap(),
            bcs::to_bytes(&symbol).unwrap(),
            bcs::to_bytes(&decimals).unwrap(),
            bcs::to_bytes(&monitor_supply).unwrap(),
        ],
    ))
}

/// Create new coins `CoinType` and deposit them into dst_addr's account.
pub fn managed_coin_mint(
    coin_type: TypeTag,
    dst_addr: AccountAddress,
    amount: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("managed_coin").to_owned(),
        ),
        ident_str!("mint").to_owned(),
        vec![coin_type],
        vec![
            bcs::to_bytes(&dst_addr).unwrap(),
            bcs::to_bytes(&amount).unwrap(),
        ],
    ))
}

/// Creating a resource that stores balance of `CoinType` on user's account, withdraw and deposit event handlers.
/// Required if user wants to start accepting deposits of `CoinType` in his account.
pub fn managed_coin_register(coin_type: TypeTag) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("managed_coin").to_owned(),
        ),
        ident_str!("register").to_owned(),
        vec![coin_type],
        vec![],
    ))
}

/// Entry function that can be used to transfer, if allow_ungated_transfer is set true.
pub fn object_transfer_call(object: AccountAddress, to: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("object").to_owned(),
        ),
        ident_str!("transfer_call").to_owned(),
        vec![],
        vec![bcs::to_bytes(&object).unwrap(), bcs::to_bytes(&to).unwrap()],
    ))
}

pub fn on_chain_config_scripts_execute_on_chain_config_proposal(
    config_t: TypeTag,
    proposal_id: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("on_chain_config_scripts").to_owned(),
        ),
        ident_str!("execute_on_chain_config_proposal").to_owned(),
        vec![config_t],
        vec![bcs::to_bytes(&proposal_id).unwrap()],
    ))
}

pub fn on_chain_config_scripts_execute_on_chain_config_proposal_v2(
    token_type: TypeTag,
    config_t: TypeTag,
    proposer_address: AccountAddress,
    proposal_id: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("on_chain_config_scripts").to_owned(),
        ),
        ident_str!("execute_on_chain_config_proposal_v2").to_owned(),
        vec![token_type, config_t],
        vec![
            bcs::to_bytes(&proposer_address).unwrap(),
            bcs::to_bytes(&proposal_id).unwrap(),
        ],
    ))
}

pub fn on_chain_config_scripts_propose_update_consensus_config(
    uncle_rate_target: u64,
    base_block_time_target: u64,
    base_reward_per_block: u128,
    base_reward_per_uncle_percent: u64,
    epoch_block_count: u64,
    base_block_difficulty_window: u64,
    min_block_time_target: u64,
    max_block_time_target: u64,
    base_max_uncles_per_block: u64,
    base_block_gas_limit: u64,
    strategy: u8,
    exec_delay: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("on_chain_config_scripts").to_owned(),
        ),
        ident_str!("propose_update_consensus_config").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&uncle_rate_target).unwrap(),
            bcs::to_bytes(&base_block_time_target).unwrap(),
            bcs::to_bytes(&base_reward_per_block).unwrap(),
            bcs::to_bytes(&base_reward_per_uncle_percent).unwrap(),
            bcs::to_bytes(&epoch_block_count).unwrap(),
            bcs::to_bytes(&base_block_difficulty_window).unwrap(),
            bcs::to_bytes(&min_block_time_target).unwrap(),
            bcs::to_bytes(&max_block_time_target).unwrap(),
            bcs::to_bytes(&base_max_uncles_per_block).unwrap(),
            bcs::to_bytes(&base_block_gas_limit).unwrap(),
            bcs::to_bytes(&strategy).unwrap(),
            bcs::to_bytes(&exec_delay).unwrap(),
        ],
    ))
}

pub fn on_chain_config_scripts_propose_update_flexi_dag_effective_height(
    new_height: u64,
    exec_delay: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("on_chain_config_scripts").to_owned(),
        ),
        ident_str!("propose_update_flexi_dag_effective_height").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&new_height).unwrap(),
            bcs::to_bytes(&exec_delay).unwrap(),
        ],
    ))
}

pub fn on_chain_config_scripts_propose_update_move_language_version(
    new_version: u64,
    exec_delay: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("on_chain_config_scripts").to_owned(),
        ),
        ident_str!("propose_update_move_language_version").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&new_version).unwrap(),
            bcs::to_bytes(&exec_delay).unwrap(),
        ],
    ))
}

pub fn on_chain_config_scripts_propose_update_reward_config(
    reward_delay: u64,
    exec_delay: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("on_chain_config_scripts").to_owned(),
        ),
        ident_str!("propose_update_reward_config").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&reward_delay).unwrap(),
            bcs::to_bytes(&exec_delay).unwrap(),
        ],
    ))
}

/// Propose to update the transaction publish option.
pub fn on_chain_config_scripts_propose_update_txn_publish_option(
    script_allowed: bool,
    module_publishing_allowed: bool,
    exec_delay: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("on_chain_config_scripts").to_owned(),
        ),
        ident_str!("propose_update_txn_publish_option").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&script_allowed).unwrap(),
            bcs::to_bytes(&module_publishing_allowed).unwrap(),
            bcs::to_bytes(&exec_delay).unwrap(),
        ],
    ))
}

/// Propose to update the transaction timeout configuration.
pub fn on_chain_config_scripts_propose_update_txn_timeout_config(
    duration_seconds: u64,
    exec_delay: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("on_chain_config_scripts").to_owned(),
        ),
        ident_str!("propose_update_txn_timeout_config").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&duration_seconds).unwrap(),
            bcs::to_bytes(&exec_delay).unwrap(),
        ],
    ))
}

/// Propose to update the VM configuration.
pub fn on_chain_config_scripts_propose_update_vm_config(
    new_config: Vec<u8>,
    exec_delay: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("on_chain_config_scripts").to_owned(),
        ),
        ident_str!("propose_update_vm_config").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&new_config).unwrap(),
            bcs::to_bytes(&exec_delay).unwrap(),
        ],
    ))
}

pub fn oracle_price_init_data_source_entry(
    oracle_t: TypeTag,
    init_value: u128,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("oracle_price").to_owned(),
        ),
        ident_str!("init_data_source_entry").to_owned(),
        vec![oracle_t],
        vec![bcs::to_bytes(&init_value).unwrap()],
    ))
}

pub fn oracle_price_register_oracle_entry(oracle_t: TypeTag, precision: u8) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("oracle_price").to_owned(),
        ),
        ident_str!("register_oracle_entry").to_owned(),
        vec![oracle_t],
        vec![bcs::to_bytes(&precision).unwrap()],
    ))
}

pub fn oracle_price_update_entry(oracle_t: TypeTag, value: u128) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("oracle_price").to_owned(),
        ),
        ident_str!("update_entry").to_owned(),
        vec![oracle_t],
        vec![bcs::to_bytes(&value).unwrap()],
    ))
}

/// Creates a new resource account and rotates the authentication key to either
/// the optional auth key if it is non-empty (though auth keys are 32-bytes)
/// or the source accounts current auth key.
pub fn resource_account_create_resource_account(
    seed: Vec<u8>,
    optional_auth_key: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("resource_account").to_owned(),
        ),
        ident_str!("create_resource_account").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&seed).unwrap(),
            bcs::to_bytes(&optional_auth_key).unwrap(),
        ],
    ))
}

/// Creates a new resource account, transfer the amount of coins from the origin to the resource
/// account, and rotates the authentication key to either the optional auth key if it is
/// non-empty (though auth keys are 32-bytes) or the source accounts current auth key. Note,
/// this function adds additional resource ownership to the resource account and should only be
/// used for resource accounts that need access to `Coin<StarcoinCoin>`.
pub fn resource_account_create_resource_account_and_fund(
    seed: Vec<u8>,
    optional_auth_key: Vec<u8>,
    fund_amount: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("resource_account").to_owned(),
        ),
        ident_str!("create_resource_account_and_fund").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&seed).unwrap(),
            bcs::to_bytes(&optional_auth_key).unwrap(),
            bcs::to_bytes(&fund_amount).unwrap(),
        ],
    ))
}

/// Batch version of APT transfer.
pub fn starcoin_account_batch_transfer(
    recipients: Vec<AccountAddress>,
    amounts: Vec<u64>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("starcoin_account").to_owned(),
        ),
        ident_str!("batch_transfer").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&recipients).unwrap(),
            bcs::to_bytes(&amounts).unwrap(),
        ],
    ))
}

/// Batch version of transfer_coins.
pub fn starcoin_account_batch_transfer_coins(
    coin_type: TypeTag,
    recipients: Vec<AccountAddress>,
    amounts: Vec<u64>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("starcoin_account").to_owned(),
        ),
        ident_str!("batch_transfer_coins").to_owned(),
        vec![coin_type],
        vec![
            bcs::to_bytes(&recipients).unwrap(),
            bcs::to_bytes(&amounts).unwrap(),
        ],
    ))
}

/// Basic account creation methods.
pub fn starcoin_account_create_account(auth_key: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("starcoin_account").to_owned(),
        ),
        ident_str!("create_account").to_owned(),
        vec![],
        vec![bcs::to_bytes(&auth_key).unwrap()],
    ))
}

/// APT Primary Fungible Store specific specialized functions,
/// Utilized internally once migration of APT to FungibleAsset is complete.
/// Convenient function to transfer APT to a recipient account that might not exist.
/// This would create the recipient APT PFS first, which also registers it to receive APT, before transferring.
/// TODO: once migration is complete, rename to just "transfer_only" and make it an entry function (for cheapest way
/// to transfer APT) - if we want to allow APT PFS without account itself
pub fn starcoin_account_fungible_transfer_only(
    to: AccountAddress,
    amount: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("starcoin_account").to_owned(),
        ),
        ident_str!("fungible_transfer_only").to_owned(),
        vec![],
        vec![bcs::to_bytes(&to).unwrap(), bcs::to_bytes(&amount).unwrap()],
    ))
}

/// Set whether `account` can receive direct transfers of coins that they have not explicitly registered to receive.
pub fn starcoin_account_set_allow_direct_coin_transfers(allow: bool) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("starcoin_account").to_owned(),
        ),
        ident_str!("set_allow_direct_coin_transfers").to_owned(),
        vec![],
        vec![bcs::to_bytes(&allow).unwrap()],
    ))
}

/// Convenient function to transfer APT to a recipient account that might not exist.
/// This would create the recipient account first, which also registers it to receive APT, before transferring.
pub fn starcoin_account_transfer(to: AccountAddress, amount: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("starcoin_account").to_owned(),
        ),
        ident_str!("transfer").to_owned(),
        vec![],
        vec![bcs::to_bytes(&to).unwrap(), bcs::to_bytes(&amount).unwrap()],
    ))
}

/// Convenient function to transfer a custom CoinType to a recipient account that might not exist.
/// This would create the recipient account first and register it to receive the CoinType, before transferring.
pub fn starcoin_account_transfer_coins(
    coin_type: TypeTag,
    to: AccountAddress,
    amount: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("starcoin_account").to_owned(),
        ),
        ident_str!("transfer_coins").to_owned(),
        vec![coin_type],
        vec![bcs::to_bytes(&to).unwrap(), bcs::to_bytes(&amount).unwrap()],
    ))
}

/// Only callable in tests and testnets where the core resources account exists.
/// Claim the delegated mint capability and destroy the delegated token.
pub fn starcoin_coin_claim_mint_capability() -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("starcoin_coin").to_owned(),
        ),
        ident_str!("claim_mint_capability").to_owned(),
        vec![],
        vec![],
    ))
}

/// Only callable in tests and testnets where the core resources account exists.
/// Create delegated token for the address so the account could claim MintCapability later.
pub fn starcoin_coin_delegate_mint_capability(to: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("starcoin_coin").to_owned(),
        ),
        ident_str!("delegate_mint_capability").to_owned(),
        vec![],
        vec![bcs::to_bytes(&to).unwrap()],
    ))
}

/// Only callable in tests and testnets where the core resources account exists.
/// Create new coins and deposit them into dst_addr's account.
pub fn starcoin_coin_mint(dst_addr: AccountAddress, amount: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("starcoin_coin").to_owned(),
        ),
        ident_str!("mint").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&dst_addr).unwrap(),
            bcs::to_bytes(&amount).unwrap(),
        ],
    ))
}

pub fn stc_genesis_initialize(
    stdlib_version: u64,
    reward_delay: u64,
    total_stc_amount: u128,
    pre_mine_stc_amount: u128,
    time_mint_stc_amount: u128,
    time_mint_stc_period: u64,
    parent_hash: Vec<u8>,
    association_auth_key: Vec<u8>,
    genesis_auth_key: Vec<u8>,
    chain_id: u8,
    _genesis_timestamp: u64,
    uncle_rate_target: u64,
    epoch_block_count: u64,
    base_block_time_target: u64,
    base_block_difficulty_window: u64,
    base_reward_per_block: u128,
    base_reward_per_uncle_percent: u64,
    min_block_time_target: u64,
    max_block_time_target: u64,
    base_max_uncles_per_block: u64,
    base_block_gas_limit: u64,
    strategy: u8,
    script_allowed: bool,
    module_publishing_allowed: bool,
    gas_schedule_blob: Vec<u8>,
    voting_delay: u64,
    voting_period: u64,
    voting_quorum_rate: u8,
    min_action_delay: u64,
    transaction_timeout: u64,
    dag_effective_height: u64,
    features: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("stc_genesis").to_owned(),
        ),
        ident_str!("initialize").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&stdlib_version).unwrap(),
            bcs::to_bytes(&reward_delay).unwrap(),
            bcs::to_bytes(&total_stc_amount).unwrap(),
            bcs::to_bytes(&pre_mine_stc_amount).unwrap(),
            bcs::to_bytes(&time_mint_stc_amount).unwrap(),
            bcs::to_bytes(&time_mint_stc_period).unwrap(),
            bcs::to_bytes(&parent_hash).unwrap(),
            bcs::to_bytes(&association_auth_key).unwrap(),
            bcs::to_bytes(&genesis_auth_key).unwrap(),
            bcs::to_bytes(&chain_id).unwrap(),
            bcs::to_bytes(&_genesis_timestamp).unwrap(),
            bcs::to_bytes(&uncle_rate_target).unwrap(),
            bcs::to_bytes(&epoch_block_count).unwrap(),
            bcs::to_bytes(&base_block_time_target).unwrap(),
            bcs::to_bytes(&base_block_difficulty_window).unwrap(),
            bcs::to_bytes(&base_reward_per_block).unwrap(),
            bcs::to_bytes(&base_reward_per_uncle_percent).unwrap(),
            bcs::to_bytes(&min_block_time_target).unwrap(),
            bcs::to_bytes(&max_block_time_target).unwrap(),
            bcs::to_bytes(&base_max_uncles_per_block).unwrap(),
            bcs::to_bytes(&base_block_gas_limit).unwrap(),
            bcs::to_bytes(&strategy).unwrap(),
            bcs::to_bytes(&script_allowed).unwrap(),
            bcs::to_bytes(&module_publishing_allowed).unwrap(),
            bcs::to_bytes(&gas_schedule_blob).unwrap(),
            bcs::to_bytes(&voting_delay).unwrap(),
            bcs::to_bytes(&voting_period).unwrap(),
            bcs::to_bytes(&voting_quorum_rate).unwrap(),
            bcs::to_bytes(&min_action_delay).unwrap(),
            bcs::to_bytes(&transaction_timeout).unwrap(),
            bcs::to_bytes(&dag_effective_height).unwrap(),
            bcs::to_bytes(&features).unwrap(),
        ],
    ))
}

/// Batch transfer token to others.
pub fn transfer_scripts_batch_peer_to_peer(
    token_type: TypeTag,
    payeees: Vec<AccountAddress>,
    _payee_auth_keys: Vec<Vec<u8>>,
    amounts: Vec<u128>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("transfer_scripts").to_owned(),
        ),
        ident_str!("batch_peer_to_peer").to_owned(),
        vec![token_type],
        vec![
            bcs::to_bytes(&payeees).unwrap(),
            bcs::to_bytes(&_payee_auth_keys).unwrap(),
            bcs::to_bytes(&amounts).unwrap(),
        ],
    ))
}

/// Batch transfer token to others.
pub fn transfer_scripts_batch_peer_to_peer_v2(
    token_type: TypeTag,
    payeees: Vec<AccountAddress>,
    amounts: Vec<u128>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("transfer_scripts").to_owned(),
        ),
        ident_str!("batch_peer_to_peer_v2").to_owned(),
        vec![token_type],
        vec![
            bcs::to_bytes(&payeees).unwrap(),
            bcs::to_bytes(&amounts).unwrap(),
        ],
    ))
}

pub fn transfer_scripts_peer_to_peer(
    token_type: TypeTag,
    payee: AccountAddress,
    _payee_auth_key: Vec<u8>,
    amount: u128,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("transfer_scripts").to_owned(),
        ),
        ident_str!("peer_to_peer").to_owned(),
        vec![token_type],
        vec![
            bcs::to_bytes(&payee).unwrap(),
            bcs::to_bytes(&_payee_auth_key).unwrap(),
            bcs::to_bytes(&amount).unwrap(),
        ],
    ))
}

pub fn transfer_scripts_peer_to_peer_v2(
    token_type: TypeTag,
    payee: AccountAddress,
    amount: u128,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("transfer_scripts").to_owned(),
        ),
        ident_str!("peer_to_peer_v2").to_owned(),
        vec![token_type],
        vec![
            bcs::to_bytes(&payee).unwrap(),
            bcs::to_bytes(&amount).unwrap(),
        ],
    ))
}

/// Execute a withdraw proposal.
pub fn treasury_scripts_execute_withdraw_proposal(
    token_t: TypeTag,
    proposer_address: AccountAddress,
    proposal_id: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("treasury_scripts").to_owned(),
        ),
        ident_str!("execute_withdraw_proposal").to_owned(),
        vec![token_t],
        vec![
            bcs::to_bytes(&proposer_address).unwrap(),
            bcs::to_bytes(&proposal_id).unwrap(),
        ],
    ))
}

/// Propose a withdraw from treasury.
pub fn treasury_scripts_propose_withdraw(
    token_t: TypeTag,
    receiver: AccountAddress,
    amount: u128,
    period: u64,
    exec_delay: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("treasury_scripts").to_owned(),
        ),
        ident_str!("propose_withdraw").to_owned(),
        vec![token_t],
        vec![
            bcs::to_bytes(&receiver).unwrap(),
            bcs::to_bytes(&amount).unwrap(),
            bcs::to_bytes(&period).unwrap(),
            bcs::to_bytes(&exec_delay).unwrap(),
        ],
    ))
}

/// Withdraw token from treasury and split the LinearWithdrawCapability.
pub fn treasury_scripts_withdraw_and_split_lt_withdraw_cap(
    token_t: TypeTag,
    for_address: AccountAddress,
    amount: u128,
    lock_period: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("treasury_scripts").to_owned(),
        ),
        ident_str!("withdraw_and_split_lt_withdraw_cap").to_owned(),
        vec![token_t],
        vec![
            bcs::to_bytes(&for_address).unwrap(),
            bcs::to_bytes(&amount).unwrap(),
            bcs::to_bytes(&lock_period).unwrap(),
        ],
    ))
}

/// Withdraw token from treasury.
pub fn treasury_scripts_withdraw_token_with_linear_withdraw_capability(
    token_t: TypeTag,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            ident_str!("treasury_scripts").to_owned(),
        ),
        ident_str!("withdraw_token_with_linear_withdraw_capability").to_owned(),
        vec![token_t],
        vec![],
    ))
}
mod decoder {
    use super::*;
    pub fn account_offer_rotation_capability(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::AccountOfferRotationCapability {
                rotation_capability_sig_bytes: bcs::from_bytes(script.args().get(0)?).ok()?,
                account_scheme: bcs::from_bytes(script.args().get(1)?).ok()?,
                account_public_key_bytes: bcs::from_bytes(script.args().get(2)?).ok()?,
                recipient_address: bcs::from_bytes(script.args().get(3)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn account_offer_signer_capability(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::AccountOfferSignerCapability {
                signer_capability_sig_bytes: bcs::from_bytes(script.args().get(0)?).ok()?,
                account_scheme: bcs::from_bytes(script.args().get(1)?).ok()?,
                account_public_key_bytes: bcs::from_bytes(script.args().get(2)?).ok()?,
                recipient_address: bcs::from_bytes(script.args().get(3)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn account_revoke_any_rotation_capability(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(_script) = payload {
            Some(EntryFunctionCall::AccountRevokeAnyRotationCapability {})
        } else {
            None
        }
    }

    pub fn account_revoke_any_signer_capability(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(_script) = payload {
            Some(EntryFunctionCall::AccountRevokeAnySignerCapability {})
        } else {
            None
        }
    }

    pub fn account_revoke_rotation_capability(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::AccountRevokeRotationCapability {
                to_be_revoked_address: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn account_revoke_signer_capability(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::AccountRevokeSignerCapability {
                to_be_revoked_address: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn account_rotate_authentication_key(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::AccountRotateAuthenticationKey {
                from_scheme: bcs::from_bytes(script.args().get(0)?).ok()?,
                from_public_key_bytes: bcs::from_bytes(script.args().get(1)?).ok()?,
                to_scheme: bcs::from_bytes(script.args().get(2)?).ok()?,
                to_public_key_bytes: bcs::from_bytes(script.args().get(3)?).ok()?,
                cap_rotate_key: bcs::from_bytes(script.args().get(4)?).ok()?,
                cap_update_table: bcs::from_bytes(script.args().get(5)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn account_rotate_authentication_key_call(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::AccountRotateAuthenticationKeyCall {
                new_auth_key: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn account_rotate_authentication_key_with_rotation_capability(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(
                EntryFunctionCall::AccountRotateAuthenticationKeyWithRotationCapability {
                    rotation_cap_offerer_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                    new_scheme: bcs::from_bytes(script.args().get(1)?).ok()?,
                    new_public_key_bytes: bcs::from_bytes(script.args().get(2)?).ok()?,
                    cap_update_table: bcs::from_bytes(script.args().get(3)?).ok()?,
                },
            )
        } else {
            None
        }
    }

    pub fn asset_mapping_assign_to_account(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::AssetMappingAssignToAccount {
                t: script.ty_args().get(0)?.clone(),
                receiper: bcs::from_bytes(script.args().get(0)?).ok()?,
                proove: bcs::from_bytes(script.args().get(1)?).ok()?,
                amount: bcs::from_bytes(script.args().get(2)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn asset_mapping_initalize_proof(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::AssetMappingInitalizeProof {
                proof_root: bcs::from_bytes(script.args().get(0)?).ok()?,
                anchor_height: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn coin_create_coin_conversion_map(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(_script) = payload {
            Some(EntryFunctionCall::CoinCreateCoinConversionMap {})
        } else {
            None
        }
    }

    pub fn coin_create_pairing(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CoinCreatePairing {
                coin_type: script.ty_args().get(0)?.clone(),
            })
        } else {
            None
        }
    }

    pub fn coin_migrate_to_fungible_store(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CoinMigrateToFungibleStore {
                coin_type: script.ty_args().get(0)?.clone(),
            })
        } else {
            None
        }
    }

    pub fn coin_transfer(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CoinTransfer {
                coin_type: script.ty_args().get(0)?.clone(),
                to: bcs::from_bytes(script.args().get(0)?).ok()?,
                amount: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn coin_upgrade_supply(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CoinUpgradeSupply {
                coin_type: script.ty_args().get(0)?.clone(),
            })
        } else {
            None
        }
    }

    pub fn dao_destroy_terminated_proposal(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DaoDestroyTerminatedProposal {
                token_t: script.ty_args().get(0)?.clone(),
                action_t: script.ty_args().get(1)?.clone(),
                proposer_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                proposal_id: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn dao_queue_proposal_action(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DaoQueueProposalAction {
                token_t: script.ty_args().get(0)?.clone(),
                action_t: script.ty_args().get(1)?.clone(),
                proposer_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                proposal_id: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn dao_featuers_proposal_execute(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DaoFeatuersProposalExecute {
                proposal_adderss: bcs::from_bytes(script.args().get(0)?).ok()?,
                proposal_id: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn dao_featuers_proposal_execute_urgent(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DaoFeatuersProposalExecuteUrgent {
                enable: bcs::from_bytes(script.args().get(0)?).ok()?,
                disable: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn dao_featuers_proposal_propose(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DaoFeatuersProposalPropose {
                enable: bcs::from_bytes(script.args().get(0)?).ok()?,
                disable: bcs::from_bytes(script.args().get(1)?).ok()?,
                exec_delay: bcs::from_bytes(script.args().get(2)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn dao_modify_config_proposal_execute(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DaoModifyConfigProposalExecute {
                token_t: script.ty_args().get(0)?.clone(),
                proposer_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                proposal_id: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn dao_modify_config_proposal_propose(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DaoModifyConfigProposalPropose {
                token_t: script.ty_args().get(0)?.clone(),
                voting_delay: bcs::from_bytes(script.args().get(0)?).ok()?,
                voting_period: bcs::from_bytes(script.args().get(1)?).ok()?,
                voting_quorum_rate: bcs::from_bytes(script.args().get(2)?).ok()?,
                min_action_delay: bcs::from_bytes(script.args().get(3)?).ok()?,
                exec_delay: bcs::from_bytes(script.args().get(4)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn dao_vote_scripts_cast_vote(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DaoVoteScriptsCastVote {
                token: script.ty_args().get(0)?.clone(),
                action_t: script.ty_args().get(1)?.clone(),
                proposer_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                proposal_id: bcs::from_bytes(script.args().get(1)?).ok()?,
                agree: bcs::from_bytes(script.args().get(2)?).ok()?,
                votes: bcs::from_bytes(script.args().get(3)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn dao_vote_scripts_flip_vote(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DaoVoteScriptsFlipVote {
                token_t: script.ty_args().get(0)?.clone(),
                action_t: script.ty_args().get(1)?.clone(),
                proposer_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                proposal_id: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn dao_vote_scripts_revoke_vote(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DaoVoteScriptsRevokeVote {
                token: script.ty_args().get(0)?.clone(),
                action: script.ty_args().get(1)?.clone(),
                proposer_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                proposal_id: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn dao_vote_scripts_revoke_vote_of_power(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DaoVoteScriptsRevokeVoteOfPower {
                token: script.ty_args().get(0)?.clone(),
                action: script.ty_args().get(1)?.clone(),
                proposer_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                proposal_id: bcs::from_bytes(script.args().get(1)?).ok()?,
                power: bcs::from_bytes(script.args().get(2)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn dao_vote_scripts_unstake_vote(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DaoVoteScriptsUnstakeVote {
                token: script.ty_args().get(0)?.clone(),
                action: script.ty_args().get(1)?.clone(),
                proposer_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                proposal_id: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn easy_gas_script_init_data_source(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::EasyGasScriptInitDataSource {
                token_type: script.ty_args().get(0)?.clone(),
                init_value: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn easy_gas_script_register(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::EasyGasScriptRegister {
                token_type: script.ty_args().get(0)?.clone(),
                precision: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn easy_gas_script_update(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::EasyGasScriptUpdate {
                token_type: script.ty_args().get(0)?.clone(),
                value: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn easy_gas_script_withdraw_gas_fee_entry(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::EasyGasScriptWithdrawGasFeeEntry {
                token_type: script.ty_args().get(0)?.clone(),
                amount: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn empty_scripts_empty_script(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(_script) = payload {
            Some(EntryFunctionCall::EmptyScriptsEmptyScript {})
        } else {
            None
        }
    }

    pub fn managed_coin_burn(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ManagedCoinBurn {
                coin_type: script.ty_args().get(0)?.clone(),
                amount: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn managed_coin_initialize(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ManagedCoinInitialize {
                coin_type: script.ty_args().get(0)?.clone(),
                name: bcs::from_bytes(script.args().get(0)?).ok()?,
                symbol: bcs::from_bytes(script.args().get(1)?).ok()?,
                decimals: bcs::from_bytes(script.args().get(2)?).ok()?,
                monitor_supply: bcs::from_bytes(script.args().get(3)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn managed_coin_mint(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ManagedCoinMint {
                coin_type: script.ty_args().get(0)?.clone(),
                dst_addr: bcs::from_bytes(script.args().get(0)?).ok()?,
                amount: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn managed_coin_register(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ManagedCoinRegister {
                coin_type: script.ty_args().get(0)?.clone(),
            })
        } else {
            None
        }
    }

    pub fn object_transfer_call(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ObjectTransferCall {
                object: bcs::from_bytes(script.args().get(0)?).ok()?,
                to: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn on_chain_config_scripts_execute_on_chain_config_proposal(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(
                EntryFunctionCall::OnChainConfigScriptsExecuteOnChainConfigProposal {
                    config_t: script.ty_args().get(0)?.clone(),
                    proposal_id: bcs::from_bytes(script.args().get(0)?).ok()?,
                },
            )
        } else {
            None
        }
    }

    pub fn on_chain_config_scripts_execute_on_chain_config_proposal_v2(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(
                EntryFunctionCall::OnChainConfigScriptsExecuteOnChainConfigProposalV2 {
                    token_type: script.ty_args().get(0)?.clone(),
                    config_t: script.ty_args().get(1)?.clone(),
                    proposer_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                    proposal_id: bcs::from_bytes(script.args().get(1)?).ok()?,
                },
            )
        } else {
            None
        }
    }

    pub fn on_chain_config_scripts_propose_update_consensus_config(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(
                EntryFunctionCall::OnChainConfigScriptsProposeUpdateConsensusConfig {
                    uncle_rate_target: bcs::from_bytes(script.args().get(0)?).ok()?,
                    base_block_time_target: bcs::from_bytes(script.args().get(1)?).ok()?,
                    base_reward_per_block: bcs::from_bytes(script.args().get(2)?).ok()?,
                    base_reward_per_uncle_percent: bcs::from_bytes(script.args().get(3)?).ok()?,
                    epoch_block_count: bcs::from_bytes(script.args().get(4)?).ok()?,
                    base_block_difficulty_window: bcs::from_bytes(script.args().get(5)?).ok()?,
                    min_block_time_target: bcs::from_bytes(script.args().get(6)?).ok()?,
                    max_block_time_target: bcs::from_bytes(script.args().get(7)?).ok()?,
                    base_max_uncles_per_block: bcs::from_bytes(script.args().get(8)?).ok()?,
                    base_block_gas_limit: bcs::from_bytes(script.args().get(9)?).ok()?,
                    strategy: bcs::from_bytes(script.args().get(10)?).ok()?,
                    exec_delay: bcs::from_bytes(script.args().get(11)?).ok()?,
                },
            )
        } else {
            None
        }
    }

    pub fn on_chain_config_scripts_propose_update_flexi_dag_effective_height(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(
                EntryFunctionCall::OnChainConfigScriptsProposeUpdateFlexiDagEffectiveHeight {
                    new_height: bcs::from_bytes(script.args().get(0)?).ok()?,
                    exec_delay: bcs::from_bytes(script.args().get(1)?).ok()?,
                },
            )
        } else {
            None
        }
    }

    pub fn on_chain_config_scripts_propose_update_move_language_version(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(
                EntryFunctionCall::OnChainConfigScriptsProposeUpdateMoveLanguageVersion {
                    new_version: bcs::from_bytes(script.args().get(0)?).ok()?,
                    exec_delay: bcs::from_bytes(script.args().get(1)?).ok()?,
                },
            )
        } else {
            None
        }
    }

    pub fn on_chain_config_scripts_propose_update_reward_config(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(
                EntryFunctionCall::OnChainConfigScriptsProposeUpdateRewardConfig {
                    reward_delay: bcs::from_bytes(script.args().get(0)?).ok()?,
                    exec_delay: bcs::from_bytes(script.args().get(1)?).ok()?,
                },
            )
        } else {
            None
        }
    }

    pub fn on_chain_config_scripts_propose_update_txn_publish_option(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(
                EntryFunctionCall::OnChainConfigScriptsProposeUpdateTxnPublishOption {
                    script_allowed: bcs::from_bytes(script.args().get(0)?).ok()?,
                    module_publishing_allowed: bcs::from_bytes(script.args().get(1)?).ok()?,
                    exec_delay: bcs::from_bytes(script.args().get(2)?).ok()?,
                },
            )
        } else {
            None
        }
    }

    pub fn on_chain_config_scripts_propose_update_txn_timeout_config(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(
                EntryFunctionCall::OnChainConfigScriptsProposeUpdateTxnTimeoutConfig {
                    duration_seconds: bcs::from_bytes(script.args().get(0)?).ok()?,
                    exec_delay: bcs::from_bytes(script.args().get(1)?).ok()?,
                },
            )
        } else {
            None
        }
    }

    pub fn on_chain_config_scripts_propose_update_vm_config(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(
                EntryFunctionCall::OnChainConfigScriptsProposeUpdateVmConfig {
                    new_config: bcs::from_bytes(script.args().get(0)?).ok()?,
                    exec_delay: bcs::from_bytes(script.args().get(1)?).ok()?,
                },
            )
        } else {
            None
        }
    }

    pub fn oracle_price_init_data_source_entry(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::OraclePriceInitDataSourceEntry {
                oracle_t: script.ty_args().get(0)?.clone(),
                init_value: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn oracle_price_register_oracle_entry(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::OraclePriceRegisterOracleEntry {
                oracle_t: script.ty_args().get(0)?.clone(),
                precision: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn oracle_price_update_entry(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::OraclePriceUpdateEntry {
                oracle_t: script.ty_args().get(0)?.clone(),
                value: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn resource_account_create_resource_account(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ResourceAccountCreateResourceAccount {
                seed: bcs::from_bytes(script.args().get(0)?).ok()?,
                optional_auth_key: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn resource_account_create_resource_account_and_fund(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(
                EntryFunctionCall::ResourceAccountCreateResourceAccountAndFund {
                    seed: bcs::from_bytes(script.args().get(0)?).ok()?,
                    optional_auth_key: bcs::from_bytes(script.args().get(1)?).ok()?,
                    fund_amount: bcs::from_bytes(script.args().get(2)?).ok()?,
                },
            )
        } else {
            None
        }
    }

    pub fn starcoin_account_batch_transfer(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::StarcoinAccountBatchTransfer {
                recipients: bcs::from_bytes(script.args().get(0)?).ok()?,
                amounts: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn starcoin_account_batch_transfer_coins(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::StarcoinAccountBatchTransferCoins {
                coin_type: script.ty_args().get(0)?.clone(),
                recipients: bcs::from_bytes(script.args().get(0)?).ok()?,
                amounts: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn starcoin_account_create_account(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::StarcoinAccountCreateAccount {
                auth_key: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn starcoin_account_fungible_transfer_only(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::StarcoinAccountFungibleTransferOnly {
                to: bcs::from_bytes(script.args().get(0)?).ok()?,
                amount: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn starcoin_account_set_allow_direct_coin_transfers(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(
                EntryFunctionCall::StarcoinAccountSetAllowDirectCoinTransfers {
                    allow: bcs::from_bytes(script.args().get(0)?).ok()?,
                },
            )
        } else {
            None
        }
    }

    pub fn starcoin_account_transfer(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::StarcoinAccountTransfer {
                to: bcs::from_bytes(script.args().get(0)?).ok()?,
                amount: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn starcoin_account_transfer_coins(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::StarcoinAccountTransferCoins {
                coin_type: script.ty_args().get(0)?.clone(),
                to: bcs::from_bytes(script.args().get(0)?).ok()?,
                amount: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn starcoin_coin_claim_mint_capability(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(_script) = payload {
            Some(EntryFunctionCall::StarcoinCoinClaimMintCapability {})
        } else {
            None
        }
    }

    pub fn starcoin_coin_delegate_mint_capability(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::StarcoinCoinDelegateMintCapability {
                to: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn starcoin_coin_mint(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::StarcoinCoinMint {
                dst_addr: bcs::from_bytes(script.args().get(0)?).ok()?,
                amount: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn stc_genesis_initialize(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::StcGenesisInitialize {
                stdlib_version: bcs::from_bytes(script.args().get(0)?).ok()?,
                reward_delay: bcs::from_bytes(script.args().get(1)?).ok()?,
                total_stc_amount: bcs::from_bytes(script.args().get(2)?).ok()?,
                pre_mine_stc_amount: bcs::from_bytes(script.args().get(3)?).ok()?,
                time_mint_stc_amount: bcs::from_bytes(script.args().get(4)?).ok()?,
                time_mint_stc_period: bcs::from_bytes(script.args().get(5)?).ok()?,
                parent_hash: bcs::from_bytes(script.args().get(6)?).ok()?,
                association_auth_key: bcs::from_bytes(script.args().get(7)?).ok()?,
                genesis_auth_key: bcs::from_bytes(script.args().get(8)?).ok()?,
                chain_id: bcs::from_bytes(script.args().get(9)?).ok()?,
                _genesis_timestamp: bcs::from_bytes(script.args().get(10)?).ok()?,
                uncle_rate_target: bcs::from_bytes(script.args().get(11)?).ok()?,
                epoch_block_count: bcs::from_bytes(script.args().get(12)?).ok()?,
                base_block_time_target: bcs::from_bytes(script.args().get(13)?).ok()?,
                base_block_difficulty_window: bcs::from_bytes(script.args().get(14)?).ok()?,
                base_reward_per_block: bcs::from_bytes(script.args().get(15)?).ok()?,
                base_reward_per_uncle_percent: bcs::from_bytes(script.args().get(16)?).ok()?,
                min_block_time_target: bcs::from_bytes(script.args().get(17)?).ok()?,
                max_block_time_target: bcs::from_bytes(script.args().get(18)?).ok()?,
                base_max_uncles_per_block: bcs::from_bytes(script.args().get(19)?).ok()?,
                base_block_gas_limit: bcs::from_bytes(script.args().get(20)?).ok()?,
                strategy: bcs::from_bytes(script.args().get(21)?).ok()?,
                script_allowed: bcs::from_bytes(script.args().get(22)?).ok()?,
                module_publishing_allowed: bcs::from_bytes(script.args().get(23)?).ok()?,
                gas_schedule_blob: bcs::from_bytes(script.args().get(24)?).ok()?,
                voting_delay: bcs::from_bytes(script.args().get(25)?).ok()?,
                voting_period: bcs::from_bytes(script.args().get(26)?).ok()?,
                voting_quorum_rate: bcs::from_bytes(script.args().get(27)?).ok()?,
                min_action_delay: bcs::from_bytes(script.args().get(28)?).ok()?,
                transaction_timeout: bcs::from_bytes(script.args().get(29)?).ok()?,
                dag_effective_height: bcs::from_bytes(script.args().get(30)?).ok()?,
                features: bcs::from_bytes(script.args().get(31)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn transfer_scripts_batch_peer_to_peer(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::TransferScriptsBatchPeerToPeer {
                token_type: script.ty_args().get(0)?.clone(),
                payeees: bcs::from_bytes(script.args().get(0)?).ok()?,
                _payee_auth_keys: bcs::from_bytes(script.args().get(1)?).ok()?,
                amounts: bcs::from_bytes(script.args().get(2)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn transfer_scripts_batch_peer_to_peer_v2(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::TransferScriptsBatchPeerToPeerV2 {
                token_type: script.ty_args().get(0)?.clone(),
                payeees: bcs::from_bytes(script.args().get(0)?).ok()?,
                amounts: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn transfer_scripts_peer_to_peer(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::TransferScriptsPeerToPeer {
                token_type: script.ty_args().get(0)?.clone(),
                payee: bcs::from_bytes(script.args().get(0)?).ok()?,
                _payee_auth_key: bcs::from_bytes(script.args().get(1)?).ok()?,
                amount: bcs::from_bytes(script.args().get(2)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn transfer_scripts_peer_to_peer_v2(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::TransferScriptsPeerToPeerV2 {
                token_type: script.ty_args().get(0)?.clone(),
                payee: bcs::from_bytes(script.args().get(0)?).ok()?,
                amount: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn treasury_scripts_execute_withdraw_proposal(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::TreasuryScriptsExecuteWithdrawProposal {
                token_t: script.ty_args().get(0)?.clone(),
                proposer_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                proposal_id: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn treasury_scripts_propose_withdraw(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::TreasuryScriptsProposeWithdraw {
                token_t: script.ty_args().get(0)?.clone(),
                receiver: bcs::from_bytes(script.args().get(0)?).ok()?,
                amount: bcs::from_bytes(script.args().get(1)?).ok()?,
                period: bcs::from_bytes(script.args().get(2)?).ok()?,
                exec_delay: bcs::from_bytes(script.args().get(3)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn treasury_scripts_withdraw_and_split_lt_withdraw_cap(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(
                EntryFunctionCall::TreasuryScriptsWithdrawAndSplitLtWithdrawCap {
                    token_t: script.ty_args().get(0)?.clone(),
                    for_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                    amount: bcs::from_bytes(script.args().get(1)?).ok()?,
                    lock_period: bcs::from_bytes(script.args().get(2)?).ok()?,
                },
            )
        } else {
            None
        }
    }

    pub fn treasury_scripts_withdraw_token_with_linear_withdraw_capability(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(
                EntryFunctionCall::TreasuryScriptsWithdrawTokenWithLinearWithdrawCapability {
                    token_t: script.ty_args().get(0)?.clone(),
                },
            )
        } else {
            None
        }
    }
}

type EntryFunctionDecoderMap = std::collections::HashMap<
    String,
    Box<
        dyn Fn(&TransactionPayload) -> Option<EntryFunctionCall>
            + std::marker::Sync
            + std::marker::Send,
    >,
>;

static SCRIPT_FUNCTION_DECODER_MAP: once_cell::sync::Lazy<EntryFunctionDecoderMap> =
    once_cell::sync::Lazy::new(|| {
        let mut map: EntryFunctionDecoderMap = std::collections::HashMap::new();
        map.insert(
            "account_offer_rotation_capability".to_string(),
            Box::new(decoder::account_offer_rotation_capability),
        );
        map.insert(
            "account_offer_signer_capability".to_string(),
            Box::new(decoder::account_offer_signer_capability),
        );
        map.insert(
            "account_revoke_any_rotation_capability".to_string(),
            Box::new(decoder::account_revoke_any_rotation_capability),
        );
        map.insert(
            "account_revoke_any_signer_capability".to_string(),
            Box::new(decoder::account_revoke_any_signer_capability),
        );
        map.insert(
            "account_revoke_rotation_capability".to_string(),
            Box::new(decoder::account_revoke_rotation_capability),
        );
        map.insert(
            "account_revoke_signer_capability".to_string(),
            Box::new(decoder::account_revoke_signer_capability),
        );
        map.insert(
            "account_rotate_authentication_key".to_string(),
            Box::new(decoder::account_rotate_authentication_key),
        );
        map.insert(
            "account_rotate_authentication_key_call".to_string(),
            Box::new(decoder::account_rotate_authentication_key_call),
        );
        map.insert(
            "account_rotate_authentication_key_with_rotation_capability".to_string(),
            Box::new(decoder::account_rotate_authentication_key_with_rotation_capability),
        );
        map.insert(
            "asset_mapping_assign_to_account".to_string(),
            Box::new(decoder::asset_mapping_assign_to_account),
        );
        map.insert(
            "asset_mapping_initalize_proof".to_string(),
            Box::new(decoder::asset_mapping_initalize_proof),
        );
        map.insert(
            "coin_create_coin_conversion_map".to_string(),
            Box::new(decoder::coin_create_coin_conversion_map),
        );
        map.insert(
            "coin_create_pairing".to_string(),
            Box::new(decoder::coin_create_pairing),
        );
        map.insert(
            "coin_migrate_to_fungible_store".to_string(),
            Box::new(decoder::coin_migrate_to_fungible_store),
        );
        map.insert(
            "coin_transfer".to_string(),
            Box::new(decoder::coin_transfer),
        );
        map.insert(
            "coin_upgrade_supply".to_string(),
            Box::new(decoder::coin_upgrade_supply),
        );
        map.insert(
            "dao_destroy_terminated_proposal".to_string(),
            Box::new(decoder::dao_destroy_terminated_proposal),
        );
        map.insert(
            "dao_queue_proposal_action".to_string(),
            Box::new(decoder::dao_queue_proposal_action),
        );
        map.insert(
            "dao_featuers_proposal_execute".to_string(),
            Box::new(decoder::dao_featuers_proposal_execute),
        );
        map.insert(
            "dao_featuers_proposal_execute_urgent".to_string(),
            Box::new(decoder::dao_featuers_proposal_execute_urgent),
        );
        map.insert(
            "dao_featuers_proposal_propose".to_string(),
            Box::new(decoder::dao_featuers_proposal_propose),
        );
        map.insert(
            "dao_modify_config_proposal_execute".to_string(),
            Box::new(decoder::dao_modify_config_proposal_execute),
        );
        map.insert(
            "dao_modify_config_proposal_propose".to_string(),
            Box::new(decoder::dao_modify_config_proposal_propose),
        );
        map.insert(
            "dao_vote_scripts_cast_vote".to_string(),
            Box::new(decoder::dao_vote_scripts_cast_vote),
        );
        map.insert(
            "dao_vote_scripts_flip_vote".to_string(),
            Box::new(decoder::dao_vote_scripts_flip_vote),
        );
        map.insert(
            "dao_vote_scripts_revoke_vote".to_string(),
            Box::new(decoder::dao_vote_scripts_revoke_vote),
        );
        map.insert(
            "dao_vote_scripts_revoke_vote_of_power".to_string(),
            Box::new(decoder::dao_vote_scripts_revoke_vote_of_power),
        );
        map.insert(
            "dao_vote_scripts_unstake_vote".to_string(),
            Box::new(decoder::dao_vote_scripts_unstake_vote),
        );
        map.insert(
            "easy_gas_script_init_data_source".to_string(),
            Box::new(decoder::easy_gas_script_init_data_source),
        );
        map.insert(
            "easy_gas_script_register".to_string(),
            Box::new(decoder::easy_gas_script_register),
        );
        map.insert(
            "easy_gas_script_update".to_string(),
            Box::new(decoder::easy_gas_script_update),
        );
        map.insert(
            "easy_gas_script_withdraw_gas_fee_entry".to_string(),
            Box::new(decoder::easy_gas_script_withdraw_gas_fee_entry),
        );
        map.insert(
            "empty_scripts_empty_script".to_string(),
            Box::new(decoder::empty_scripts_empty_script),
        );
        map.insert(
            "managed_coin_burn".to_string(),
            Box::new(decoder::managed_coin_burn),
        );
        map.insert(
            "managed_coin_initialize".to_string(),
            Box::new(decoder::managed_coin_initialize),
        );
        map.insert(
            "managed_coin_mint".to_string(),
            Box::new(decoder::managed_coin_mint),
        );
        map.insert(
            "managed_coin_register".to_string(),
            Box::new(decoder::managed_coin_register),
        );
        map.insert(
            "object_transfer_call".to_string(),
            Box::new(decoder::object_transfer_call),
        );
        map.insert(
            "on_chain_config_scripts_execute_on_chain_config_proposal".to_string(),
            Box::new(decoder::on_chain_config_scripts_execute_on_chain_config_proposal),
        );
        map.insert(
            "on_chain_config_scripts_execute_on_chain_config_proposal_v2".to_string(),
            Box::new(decoder::on_chain_config_scripts_execute_on_chain_config_proposal_v2),
        );
        map.insert(
            "on_chain_config_scripts_propose_update_consensus_config".to_string(),
            Box::new(decoder::on_chain_config_scripts_propose_update_consensus_config),
        );
        map.insert(
            "on_chain_config_scripts_propose_update_flexi_dag_effective_height".to_string(),
            Box::new(decoder::on_chain_config_scripts_propose_update_flexi_dag_effective_height),
        );
        map.insert(
            "on_chain_config_scripts_propose_update_move_language_version".to_string(),
            Box::new(decoder::on_chain_config_scripts_propose_update_move_language_version),
        );
        map.insert(
            "on_chain_config_scripts_propose_update_reward_config".to_string(),
            Box::new(decoder::on_chain_config_scripts_propose_update_reward_config),
        );
        map.insert(
            "on_chain_config_scripts_propose_update_txn_publish_option".to_string(),
            Box::new(decoder::on_chain_config_scripts_propose_update_txn_publish_option),
        );
        map.insert(
            "on_chain_config_scripts_propose_update_txn_timeout_config".to_string(),
            Box::new(decoder::on_chain_config_scripts_propose_update_txn_timeout_config),
        );
        map.insert(
            "on_chain_config_scripts_propose_update_vm_config".to_string(),
            Box::new(decoder::on_chain_config_scripts_propose_update_vm_config),
        );
        map.insert(
            "oracle_price_init_data_source_entry".to_string(),
            Box::new(decoder::oracle_price_init_data_source_entry),
        );
        map.insert(
            "oracle_price_register_oracle_entry".to_string(),
            Box::new(decoder::oracle_price_register_oracle_entry),
        );
        map.insert(
            "oracle_price_update_entry".to_string(),
            Box::new(decoder::oracle_price_update_entry),
        );
        map.insert(
            "resource_account_create_resource_account".to_string(),
            Box::new(decoder::resource_account_create_resource_account),
        );
        map.insert(
            "resource_account_create_resource_account_and_fund".to_string(),
            Box::new(decoder::resource_account_create_resource_account_and_fund),
        );
        map.insert(
            "starcoin_account_batch_transfer".to_string(),
            Box::new(decoder::starcoin_account_batch_transfer),
        );
        map.insert(
            "starcoin_account_batch_transfer_coins".to_string(),
            Box::new(decoder::starcoin_account_batch_transfer_coins),
        );
        map.insert(
            "starcoin_account_create_account".to_string(),
            Box::new(decoder::starcoin_account_create_account),
        );
        map.insert(
            "starcoin_account_fungible_transfer_only".to_string(),
            Box::new(decoder::starcoin_account_fungible_transfer_only),
        );
        map.insert(
            "starcoin_account_set_allow_direct_coin_transfers".to_string(),
            Box::new(decoder::starcoin_account_set_allow_direct_coin_transfers),
        );
        map.insert(
            "starcoin_account_transfer".to_string(),
            Box::new(decoder::starcoin_account_transfer),
        );
        map.insert(
            "starcoin_account_transfer_coins".to_string(),
            Box::new(decoder::starcoin_account_transfer_coins),
        );
        map.insert(
            "starcoin_coin_claim_mint_capability".to_string(),
            Box::new(decoder::starcoin_coin_claim_mint_capability),
        );
        map.insert(
            "starcoin_coin_delegate_mint_capability".to_string(),
            Box::new(decoder::starcoin_coin_delegate_mint_capability),
        );
        map.insert(
            "starcoin_coin_mint".to_string(),
            Box::new(decoder::starcoin_coin_mint),
        );
        map.insert(
            "stc_genesis_initialize".to_string(),
            Box::new(decoder::stc_genesis_initialize),
        );
        map.insert(
            "transfer_scripts_batch_peer_to_peer".to_string(),
            Box::new(decoder::transfer_scripts_batch_peer_to_peer),
        );
        map.insert(
            "transfer_scripts_batch_peer_to_peer_v2".to_string(),
            Box::new(decoder::transfer_scripts_batch_peer_to_peer_v2),
        );
        map.insert(
            "transfer_scripts_peer_to_peer".to_string(),
            Box::new(decoder::transfer_scripts_peer_to_peer),
        );
        map.insert(
            "transfer_scripts_peer_to_peer_v2".to_string(),
            Box::new(decoder::transfer_scripts_peer_to_peer_v2),
        );
        map.insert(
            "treasury_scripts_execute_withdraw_proposal".to_string(),
            Box::new(decoder::treasury_scripts_execute_withdraw_proposal),
        );
        map.insert(
            "treasury_scripts_propose_withdraw".to_string(),
            Box::new(decoder::treasury_scripts_propose_withdraw),
        );
        map.insert(
            "treasury_scripts_withdraw_and_split_lt_withdraw_cap".to_string(),
            Box::new(decoder::treasury_scripts_withdraw_and_split_lt_withdraw_cap),
        );
        map.insert(
            "treasury_scripts_withdraw_token_with_linear_withdraw_capability".to_string(),
            Box::new(decoder::treasury_scripts_withdraw_token_with_linear_withdraw_capability),
        );
        map
    });
